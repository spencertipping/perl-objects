sdocp('interface.js.sdoc', 'Self-modifying Perl web interface | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis interface lets users open self-modifying Perl files as web pages. Attributes will be shown in a list, and each one can be expanded to show its value.\n\ncaterwaul.clone(\'std seq continuation montenegro parser\')(function ($) {\n  $(fn_[$(\'body\').empty().append(the_interface),\n\n  where*[original_html           = $(\'body\').html(),\n\n         parse_attributes(s)     = l*[namespace             = peg[[c(/[\\s\\n]+/, 1)] % c(/meta::(\\w+)/, 7) >> fn[xs][xs[1][1]]],\n                                      string                = peg[c(\'\\\'\') % (c(/[^\\\\\']/, 1) / (c(/\\\\(.)/, 2) >> fn[xs][xs[1]]))[0] % c(\'\\\'\') >> fn[xs][xs[1].join(\'\')]],\n                                      here_document         = peg[c(\'<<\') % string >> fn[xs][xs[1]]],\n\n                                      invocation_common     = peg[namespace % c(\'(\') % string % c(/,\\s*/, 1) >> fn[xs][{namespace: xs[0], attribute: xs[2]}]],\n\n                                      short_form_invocation = peg[invocation_common % string % c(\');\\n\') >> fn[xs][xs[0] /se[_.value = xs[1]]]],\n\n                                      long_form_invocation  = l*[beginning            = peg[invocation_common % here_document % c(\');\\n\') >> fn[xs][xs[0] /se[_.marker = xs[1]]]],\n                                                                 ending(end)          = peg[(reject(c(end)) % c(fn_[1]))[0] % c(end) >> fn[xs][seq[~xs[0] *[_[1]]].join(\'\')]],\n                                                                 parse_heredoc(input) = l*[begin = beginning(input),\n                                                                                           end   = begin.result && ending(begin.result.marker)(begin)] in\n                                                                                        end /se[_.result = begin.result /se[_.value = end.result], when[begin.result]]] in\n                                                              parse_heredoc,\n\n                                      attribute             = peg[short_form_invocation / long_form_invocation],\n                                      attributes            = peg[attribute[0]],\n\n                                      unescape(s)           = s.replace(/&lt;/gi, \'<\').replace(/&gt;/gi, \'>\').replace(/&amp;/gi, \'&\'),\n                                      trim_bootstrap(s)     = s.replace(/^(?:(?!\\nmeta::\\w+\\()(?:.|\\n))*\\n/, \'\')] in\n\n                                   attributes(trim_bootstrap(unescape(s))),\n\n         partition(name, xs)     = html[h1(name), div.attributes] /se[_.find(\'.attributes\').append(seq[~xs *+attribute])],\n         attribute(x)            = html[div.attribute(a.name(x.name), pre.contents(x.value))] /se[\n                                   _.find(\'.name\').clickable(fn_[_.find(\'.contents\').toggle()]),\n                                   _.find(\'.contents\').hide()],\n\n         separate_namespaces(xs) = l[namespace_object = seq[~xs *[[_.namespace, true]]].object()] in seq[sk[namespace_object] *[[_, seq[xs %x[x.namespace === _]]]]].object(),\n         namespace_sections(xs)  = l[partitions = separate_namespaces(xs)] in seq[sp[partitions] *[partition(_[0], _[1])]],\n\n         the_interface           = namespace_sections(parse_attributes(original_html))]])})($);\n');