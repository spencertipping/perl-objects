#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

meta::meta('configure', <<'__25976e07665878d3fae18f050160343f');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__25976e07665878d3fae18f050160343f

meta::meta('externalize', <<'__9141b4e8752515391385516ae94b23b5');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9141b4e8752515391385516ae94b23b5

meta::meta('functor::editable', <<'__23cd7b7dc81d5cebd632c7543a30af99');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;
  
  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return preprocess(retrieve($attribute))                                              if $options{preprocess};
      return retrieve($attribute);
    };
  };
}
__23cd7b7dc81d5cebd632c7543a30af99

meta::meta('functor::filter', <<'__2b90212a796dd5cb190694c1b3fa77e7');
# Creates a filter type. These are stored in their own namespaces, but are enumerable
# by their attribute names (which match their function names, conveniently).

sub meta::functor::filter {
  my ($typename) = @_;

  meta::configure $typename, extension => '.pl', inherit => 1;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;
    meta::externalize "${typename}::$name", "${typename}::$name", eval "sub{\n$value\n}";
    warn $@ if $@;
  };
}
__2b90212a796dd5cb190694c1b3fa77e7

meta::meta('functor::section', <<'__7ec9c7e2cf5f013a9ad353743c4e715d');
sub meta::functor::section {
  my ($typename, %options) = @_;

  meta::configure $typename, %options, inherit => 0;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;
    meta::externalize $name, "${typename}::$name", sub {
      edit("${typename}::$name");
    };
  };
}
__7ec9c7e2cf5f013a9ad353743c4e715d

meta::meta('internal::runtime', <<'__0172b18c9b9311477d2f6b8c16bb44c2');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__0172b18c9b9311477d2f6b8c16bb44c2

meta::meta('type::asm_section', <<'__8148e66be6f3817d532b6e9eefff8fdc');
meta::functor::section 'asm_section', extension => '.asmtex';
__8148e66be6f3817d532b6e9eefff8fdc

meta::meta('type::bootstrap', <<'__297d03fb32df03b46ea418469fc4e49e');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__297d03fb32df03b46ea418469fc4e49e

meta::meta('type::code_filter', <<'__fe8409ace442357793b70c5e4b09541f');
meta::functor::filter 'code_filter';
__fe8409ace442357793b70c5e4b09541f

meta::meta('type::cpp_section', <<'__d7334e147c03395ca4fde89c2fc319ca');
meta::functor::section 'cpp_section', extension => '.cpptex';
__d7334e147c03395ca4fde89c2fc319ca

meta::meta('type::data', <<'__58d8027f20099b28a159eaac67314051');
meta::functor::editable 'data', extension => '', inherit => 0, default => 'cat';
__58d8027f20099b28a159eaac67314051

meta::meta('type::function', <<'__af5dd5ecc27fe503f68b041791bee6ca');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__af5dd5ecc27fe503f68b041791bee6ca

meta::meta('type::internal_function', <<'__cb453a81adfa24b238c9b69e0b372ec8');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  warn $@ if $@;
};
__cb453a81adfa24b238c9b69e0b372ec8

meta::meta('type::java_section', <<'__71571ca8dcfe5aca392fc772c6008897');
meta::functor::section 'java_section', extension => '.javatex';
__71571ca8dcfe5aca392fc772c6008897

meta::meta('type::library', <<'__455137a61f5af29340946d69bc68d663');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;

  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__455137a61f5af29340946d69bc68d663

meta::meta('type::line_filter', <<'__d2bdb3ece44235778ec7402481d95582');
meta::functor::filter 'line_filter';
__d2bdb3ece44235778ec7402481d95582

meta::meta('type::message_color', <<'__794bf137c425293738f07636bcfb5c55');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__794bf137c425293738f07636bcfb5c55

meta::meta('type::meta', <<'__640f25635ce2365b0648962918cf9932');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__640f25635ce2365b0648962918cf9932

meta::meta('type::note', <<'__08f3bf50999ba8de0702a6a95fdfc7ff');
meta::functor::editable 'note', extension => '', inherit => 0, default => 'edit';
__08f3bf50999ba8de0702a6a95fdfc7ff

meta::meta('type::section', <<'__a393d88693f2bb6471a46c7e300e6920');
meta::functor::section 'section', extension => '.cltex';
__a393d88693f2bb6471a46c7e300e6920

meta::meta('type::state', <<'__c1f29670be26f1df6100ffe4334e1202');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__c1f29670be26f1df6100ffe4334e1202

meta::meta('type::template', <<'__31e3d1be8d2d32b285ebb90645d5f37a');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__31e3d1be8d2d32b285ebb90645d5f37a

meta::meta('type::unlit_converter', <<'__f9f6134ac8b62ac44bd8556451562a42');
meta::functor::filter 'unlit_converter';
__f9f6134ac8b62ac44bd8556451562a42

meta::meta('type::vim_highlighter', <<'__d6ea5b59c918d4e2cfebf5c880f43be8');
meta::functor::editable 'vim_highlighter', extension => '.vim', inherit => 1, default => 'edit';
__d6ea5b59c918d4e2cfebf5c880f43be8

meta::meta('type::watch', <<'__8e208e776f55ef2c4825deb888a41590');
meta::functor::editable 'watch', prefix => 'watch::', inherit => 1, extension => '.pl', default => 'cat';
__8e208e776f55ef2c4825deb888a41590

meta::asm_section('asm-introduction', <<'__2d1cba5a3763bf1c481e39ac9ba7bb3a');
- Introduction to Assembly Literate Coding
  Assembly-language snippets are specified in much the same way as C++ snippets. The only difference is that the \verb|asm| marker is used instead of \verb|cpp|.

  :: asm name=test.s
  main:
    movl $1, %eax
    ret
  :.
__2d1cba5a3763bf1c481e39ac9ba7bb3a

meta::bootstrap('initialization', <<'__d2491ab72f79f70883bd583202562e94');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

__d2491ab72f79f70883bd583202562e94

meta::code_filter('asm', <<'__b04e2d01bd073255a951f871935f6696');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sasm(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{asmcode}" if $settings{'begin'};
  } else {
    return '\begin{asmcode}' if $settings{'begin'};
  }

  return '\end{asmcode}' if $settings{'end'};
}

return $line;
__b04e2d01bd073255a951f871935f6696

meta::code_filter('cpp', <<'__40a06c5c992c42ae0fb1b8376f2598ee');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\scpp(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{cppcode}" if $settings{'begin'};
  } else {
    return '\begin{cppcode}' if $settings{'begin'};
  }

  return '\end{cppcode}' if $settings{'end'};
}

return $line;
__40a06c5c992c42ae0fb1b8376f2598ee

meta::code_filter('java', <<'__8461fc00a8f9516e26889b9108eb3dbc');
use File::Path 'mkpath';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sjava(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if ($properties{'class'}) {
    my $classname         = $properties{'class'};
    my $package_directory = $properties{'package'};
    $package_directory =~ tr[.][/];

    mkpath(my $directory = &{'source-directory'}() . '/' . $package_directory);
    open my $fh, $settings{'begin'} ? '>' : '>>', "$directory/${classname}.java";
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$properties{package}.$properties{class}}\n\\begin{javacode}" if $settings{'begin'};
  }

  return '\begin{javacode}' if $settings{'begin'};
  return '\end{javacode}'   if $settings{'end'};
}

return $line;
__8461fc00a8f9516e26889b9108eb3dbc

meta::code_filter('resource', <<'__a8f830678fa158a19c0e174a2d8e1211');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sresource(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{resource}" if $settings{'begin'};
  } else {
    return '\begin{resource}' if $settings{'begin'};
  }

  return '\end{resource}' if $settings{'end'};
}

return $line;
__a8f830678fa158a19c0e174a2d8e1211

meta::code_filter('verbatim', <<'__88f0d576a60ba40fe951bfce0677aa4f');
my ($line, %settings) = @_;

unless ($settings{'name'}) {
  return '\begin{verbatim}' if $settings{'begin'};
  return '\end{verbatim}'   if $settings{'end'};
}

return $line;
__88f0d576a60ba40fe951bfce0677aa4f

meta::cpp_section('cpp-introduction', <<'__bdb0ea7cecc426699b7a476dace9232c');
- Introduction to C++ Literate Coding
  The C++ literate code interface is much like the Java one, except that code sections use the \verb|name=x| attribute rather than \verb|class=| and \verb|package=|. The name is expected to
  include an extension, so for example \verb|:: cpp name=src/foo.h| is a correct heading.

  :: cpp name=hello.cc
  #include<iostream>
  int main () {
    std::cout << "Hello world!" << std::endl;
  }
  :.
__bdb0ea7cecc426699b7a476dace9232c

meta::data('default-action', <<'__53508551b72484e92f7acb844808db7b');
shell
__53508551b72484e92f7acb844808db7b

meta::data('license', <<'__3c6177256de0fddb721f534c3ad8c0ee');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__3c6177256de0fddb721f534c3ad8c0ee

meta::data('name', <<'__175b00ca688a0edde91d499786cb437b');
literate-project
__175b00ca688a0edde91d499786cb437b

meta::data('quiet', <<'__9ce6820642996915d3434b56a7a09ded');
1
__9ce6820642996915d3434b56a7a09ded

meta::data('watching', <<'__9ce6820642996915d3434b56a7a09ded');
0
__9ce6820642996915d3434b56a7a09ded

meta::function('cat', <<'__c8e76a0cf10e2061e9cf9e1643922c3e');
my ($name) = @_;
$data{$name};
__c8e76a0cf10e2061e9cf9e1643922c3e

meta::function('clone', <<'__fec8cf43b197da97cfd5e49d75891d57');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__fec8cf43b197da97cfd5e49d75891d57

meta::function('cp', <<'__ffba0c53d9c2d03d8d6e5f9692f496ae');
my ($from, $to) = @_;
my $exists = exists $data{$from};
associate($to, retrieve($from)) if $exists;
messages::error("No such attribute $from") unless $exists;
retrieve($from);
__ffba0c53d9c2d03d8d6e5f9692f496ae

meta::function('create', <<'__3349f4fb38464e1869a43e25af881986');
my ($name, $value) = @_;

messages::error("Attribute $name already exists.") if grep $_ eq $name, keys %data;
if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__3349f4fb38464e1869a43e25af881986

meta::function('current-state', <<'__0d932bd14547669ffbc86fde3ae9d050');
my @valid_keys   = grep ! /^internal::runtime$/ && ! /^state::/, sort keys %data;
my @ordered_keys = (grep(/^meta::/, @valid_keys), grep(! /^meta::/, @valid_keys));
join "\n", map serialize_single($_), @ordered_keys;
__0d932bd14547669ffbc86fde3ae9d050

meta::function('edit', <<'__fd66065bde6c1783dd3345474f93cc9e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

messages::error("Attribute $name does not exist.") unless grep $_ eq $name, keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, attribute => $name, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__fd66065bde6c1783dd3345474f93cc9e

meta::function('exists', <<'__3c6aa32026f04564ec4861c77a8e6465');
my $name = shift;
grep {$_ eq $name} keys %data;
__3c6aa32026f04564ec4861c77a8e6465

meta::function('export', <<'__6d9cbe5959a6431316eb690cd8dbc79a');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  messages::error("Not enough arguments");
}
__6d9cbe5959a6431316eb690cd8dbc79a

meta::function('hash', <<'__7c4145cf6e97dfb9ab04a613866751d3');
my ($data) = @_;
fast_hash($data);
__7c4145cf6e97dfb9ab04a613866751d3

meta::function('import', <<'__84d29edfe7ad2119465fdcf7d037ed1c');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__84d29edfe7ad2119465fdcf7d037ed1c

meta::function('import-bundle', <<'__f8e525756a0de302fa1d1d209d167e3b');
eval join '', <STDIN>;
messages::error($@) if $@;
__f8e525756a0de302fa1d1d209d167e3b

meta::function('load-state', <<'__878f141333993ead4d272027ad301eee');
my ($state_name) = @_;
my $state = retrieve("state::$state_name");

terminal::message('state', 'Saving current state into _...');
&{'save-state'}('_');

terminal::message('state', 'Removing attributes from %data and unexternalizing functions...');
delete $data{$_} for grep ! /^state::/ && ! /^internal::runtime$/, keys %data;
%externalized_functions = ();

terminal::message('state', "Restoring state $state_name...");
eval($state);
terminal::message('error', $@) if $@;
reload();
verify();
__878f141333993ead4d272027ad301eee

meta::function('lock', <<'__d94992bf224487f5bfd439eb822db309');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__d94992bf224487f5bfd439eb822db309

meta::function('ls', <<'__d900070fd20c5c0ae08280b0f354666f');
my $criteria = join '|', @_;
my @lines = grep /$criteria/ && defined $data{$externalized_functions{$_}}, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__d900070fd20c5c0ae08280b0f354666f

meta::function('ls-a', <<'__f2fdfdd82d77a876b485332dbd1446fa');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . sprintf('%6d  ', length(serialize_single($_))) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__f2fdfdd82d77a876b485332dbd1446fa

meta::function('mv', <<'__994133604ac769fe978c4c127fd5011c');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

return messages::error("'$from' does not exist.") unless grep $from, keys %data;
return messages::error("The namepsace '$destination_namespace' does not exist") unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__994133604ac769fe978c4c127fd5011c

meta::function('note', <<'__bcbfeac6dd2112f47296265444570a6e');
# Creates a note with a given name, useful for jotting things down.
create("note::$_[0]");
__bcbfeac6dd2112f47296265444570a6e

meta::function('perl', <<'__d8818fd77e9e7ce68811e0947dfcc206');
my $result = eval($_[0]);
$@ ? $@ : $result;
__d8818fd77e9e7ce68811e0947dfcc206

meta::function('pop-state', <<'__90a6d3599a269ca0bef8126df7aba8e0');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__90a6d3599a269ca0bef8126df7aba8e0

meta::function('preprocess', <<'__35d9aceabda1fda76e1f4a0ee056c21f');
# Implements a simple preprocessing language.

my ($string, %options) = @_;
my $delimiter          = $options{delimiter} || '::';
my $expansions         = 0;

1 while ++$expansions < 100 and
        $string =~ s/^\h*$delimiter \s+ (\S+) \s* (.*) $/${\(&{"template::$1"}($2))}/xm ||
        $string =~ s/^\h*$delimiter<(\S+)> \h* (\S+) \h* (.*)$ \v ([.\v]*?) ^\h*\1$/${\(&{"template::$2"}($3, $4))}/xm;
$string;
__35d9aceabda1fda76e1f4a0ee056c21f

meta::function('push-state', <<'__ba601ddf7dce874ce79dd37a936ffdcc');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ba601ddf7dce874ce79dd37a936ffdcc

meta::function('reload', <<'__5208dbe97a0fd49e9ef075f33cbada53');
execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;
__5208dbe97a0fd49e9ef075f33cbada53

meta::function('rm', <<'__e3c840f6c0b12ec504df30595b5bb94d');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__e3c840f6c0b12ec504df30595b5bb94d

meta::function('save', <<'__026f80315df6aef78ccb734c6ab250f3');
if (! verify()) {
  messages::error("$0 has not been updated.");
} else {
  my $serialized_data = serialize();
  eval {file::write($0, $serialized_data)};
  messages::error($@) if $@;
  terminal::message('info', "$0 saved successfully.");
}
__026f80315df6aef78ccb734c6ab250f3

meta::function('save-state', <<'__5c5b586331e25951140ced6442d9fe2b');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
associate("state::$state_name", &{'current-state'}(), execute => 1);
__5c5b586331e25951140ced6442d9fe2b

meta::function('serialize', <<'__d7b3affaece3a36d5cfc051b88a5b76e');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && (! $criteria || m/$criteria/), sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;
__d7b3affaece3a36d5cfc051b88a5b76e

meta::function('serialize_single', <<'__91663f820a05ff4029a200fbfd7285bc');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $meta_function_name = 'meta::' . namespace($name);
my $invocation_name    = basename($name);

return "$meta_function_name('$invocation_name', '$contents');"   if $contents =~ /^[^\n']*$/;
return "$meta_function_name('$invocation_name', \"$contents\");" if $contents =~ /^[^\n"\\\$@%&]*$/;

my $delimiter = '__' . fast_hash($contents);
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__91663f820a05ff4029a200fbfd7285bc

meta::function('shell', <<'__364c77a8a88ef137c00350b27d2d2a5e');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $output = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';
  associate('data::watching', 0, execute => 1), next if $function_name eq 'disable-watch';
  associate('data::watching', 1, execute => 1), next if $function_name eq 'enable-watch';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      chomp(my $result = eval {&$function_name(@args)});
      messages::warning($@) if $@;
      print $output $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  if (watching()) {
    for my $watch (map retrieve($_), grep /^watch::/, sort keys %data) {
      terminal::message('watch',   "$watch => " . eval($watch));
      terminal::message('warning', "Error evaluating watched expression $watch: $@") if $@;
    }
  }

  $prompt = name() . '$ ';
}
__364c77a8a88ef137c00350b27d2d2a5e

meta::function('size', <<'__ed32c644d604fdc61dda48bd3fbe5559');
length(serialize());
__ed32c644d604fdc61dda48bd3fbe5559

meta::function('snapshot', <<'__ccb6335f4837338be1d73ccc5f81973d');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('state', "Created snapshot at $finalname.");
__ccb6335f4837338be1d73ccc5f81973d

meta::function('state', <<'__e17520e3a5d81d788ae995fd8ac47cb9');
my @keys = sort keys %data;
my $hash = fast_hash(scalar @keys);
$hash = fast_hash($hash . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__e17520e3a5d81d788ae995fd8ac47cb9

meta::function('unlock', <<'__b1bdb7eb224487f5bfd439ebb997c823');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__b1bdb7eb224487f5bfd439ebb997c823

meta::function('update-from', <<'__c9570d6953ba16e3abaa217b0b202b3e');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.

my $target  = $_[0] or die 'Must specify another script to pull data from.';
my @options = grep /^-/, @_;

&{'save-state'}('before-update');

terminal::message('info', 'Updating meta attributes...');
eval qx($target serialize '^meta::');
terminal::message('warning', $@) if $@;
terminal::message('warning', 'One of the meta-attributes triggered a verification failure.') unless verify();

terminal::message('info', 'Updating non-meta attributes...');
my $combined_pattern = join '|', map "^${_}::", grep ! (/^meta$/ || /^internal$/) && $transient{inherit}{$_}, sort keys %{$transient{inherit}};
eval qx($target serialize '$combined_pattern');
terminal::message('warning', $@) if $@;
reload();

if (verify()) {
  terminal::message('info', "Successfully updated from $_[0]. Run 'load-state before-backup' to undo this change.");
} elsif (grep /^--force$/o || /^-f$/o, @options) {
  terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
  terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
  terminal::message('info',    'Run "load-state before-backup" to undo the update and return to a working state.');
} else {
  terminal::message('error', 'Verification failed after the upgrade was complete.');
  terminal::message('info',  "$0 has been reverted to its pre-upgrade state.");
  terminal::message('info',  "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
  &{'load-state'}('before-update');
}
__c9570d6953ba16e3abaa217b0b202b3e

meta::function('usage', <<'__234b1da5bb4e34d72a932ab68aad5052');
<<"EOD" . ls ();
Usage: $0 action [arguments]
Defined actions (and the attribute that defines them):
EOD
__234b1da5bb4e34d72a932ab68aad5052

meta::function('verify', <<'__e8ff828f42cdc7d759b70bb81721ddb6');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
$transient{temporary_filename} = $temporary_filename;
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
unlink $temporary_filename if $result;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;

$result;
__e8ff828f42cdc7d759b70bb81721ddb6

meta::function('vim', <<'__bd231af998c353790253bc6660be0b90');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__bd231af998c353790253bc6660be0b90

meta::internal_function('associate', <<'__9c33cd95ac3bfa9de2f9de12c866b1c7');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__9c33cd95ac3bfa9de2f9de12c866b1c7

meta::internal_function('basename', <<'__62efb9f22157835940af1d5feae98d98');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__62efb9f22157835940af1d5feae98d98

meta::internal_function('complete', <<'__f14ae2337c0653b6bb6fd02bb6493646');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__f14ae2337c0653b6bb6fd02bb6493646

meta::internal_function('execute', <<'__2d5b6f18c13943d6a0de15e9c348d428');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__2d5b6f18c13943d6a0de15e9c348d428

meta::internal_function('fast_hash', <<'__ac70f469e697725cfb87629833434ab1');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__ac70f469e697725cfb87629833434ab1

meta::internal_function('file::read', <<'__186bbcef8f6f0dd8b72ba0fdeb1de040');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__186bbcef8f6f0dd8b72ba0fdeb1de040

meta::internal_function('file::write', <<'__d05a3256f22a7a49afb85e8db507ab50');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__d05a3256f22a7a49afb85e8db507ab50

meta::internal_function('fnv_hash', <<'__8d001a3a7988631bab21a41cee559758');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__8d001a3a7988631bab21a41cee559758

meta::internal_function('invoke_editor_on', <<'__d54f75530d8fe78e078c92be20c72297');
my ($data, %options) = @_;
my $editor           = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $extension        = $options{extension} || '';
my $attribute        = $options{attribute} || '';

my $filename         = temporary_name() . "-$attribute" . $extension;

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__d54f75530d8fe78e078c92be20c72297

meta::internal_function('messages::error', <<'__5af9120535afe26fa6828f477abe833c');
my ($message) = @_;
terminal::message('error', $message);
die;
__5af9120535afe26fa6828f477abe833c

meta::internal_function('messages::warning', <<'__2877a0b67326120f9d43089368e6c4f3');
my ($message) = @_;
terminal::message('warning', $message);
__2877a0b67326120f9d43089368e6c4f3

meta::internal_function('namespace', <<'__93213d60cafb9627e0736b48cd1f0760');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__93213d60cafb9627e0736b48cd1f0760

meta::internal_function('retrieve', <<'__7c96ec5935b22f2766064ea54f1e868a');
@data{@_};
__7c96ec5935b22f2766064ea54f1e868a

meta::internal_function('serialize_single', <<'__5ad359e62adc135871d39fcb7f4c2a93');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = '__' . fast_hash($contents);
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__5ad359e62adc135871d39fcb7f4c2a93

meta::internal_function('state_based_filename', <<'__218815c285975367ae0324bf5c3f5409');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__218815c285975367ae0324bf5c3f5409

meta::internal_function('temporary_name', <<'__0fb1402061581b69822f913631b4a9d9');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__0fb1402061581b69822f913631b4a9d9

meta::java_section('java-introduction', <<'__e47faa697ea1f1cc04710f2adbf0d0ba');
- Introduction to Java Literate Coding
  Literate coding allows you to write \TeX{} primarily, but insert Java code snippets where appropriate.\footnote{Take a look at {\tt java\_section::java-introduction} to see the how to set
  the language and options for code sections.} For example:

  :: java class=test
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is a test class");
    }
  }
  :.

  :: java class=test package=com.spencertipping
  package com.spencertipping;
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is in package com.spencertipping.");
    }
  }
  :.

  Compiling the system is also simple:

  ::
  $ ./my-project compile
  :.

  This generates all of the Java source files in a directory, usually {\tt /tmp/src/}. The output directory can be changed like this:

  ::
  $ ./my-project source-directory = src/
  :.
__e47faa697ea1f1cc04710f2adbf0d0ba

meta::library('terminal', <<'__6ac64319df3f331f76b5213634f2af51');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color   'debug',   'blue';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__6ac64319df3f331f76b5213634f2af51

meta::line_filter('convert_header_info', <<'__d9b9a880b0761b87e53e4e6b02487030');
my ($line) = @_;

$line =~ s/^= (.*)$/\\title{$1}/;
$line =~ s/^a (.*)$/\\author{$1}/;
$line =~ s/^d (.*)$/\\date{$1}/;

my $document_header = '\begin{document}\maketitle';
$document_header .= '\tableofcontents' if &{'table-of-contents'}();

$line =~ s/^begin$/$document_header/;

$line;
__d9b9a880b0761b87e53e4e6b02487030

meta::line_filter('convert_itemized_environments', <<'__4fa1a20b30da869cb74ee0ec45b03657');
my ($line) = @_;

$line =~ s/^\s*\+ /\\item /;
$line =~ s/^\s*\+\[([^\]]*)\] /\\item[\1] /;

$line =~ s/^\s*e\[$/\\begin{enumerate}/;
$line =~ s/^\s*i\[$/\\begin{itemize}/;
$line =~ s/^\s*d\[$/\\begin{description}/;

$line =~ s/^\s*a\[$/\\begin{align*}/;

$line =~ s/^\s*\]e$/\\end{enumerate}/;
$line =~ s/^\s*\]i$/\\end{itemize}/;
$line =~ s/^\s*\]d$/\\end{description}/;

$line =~ s/^\s*\]a$/\\end{align*}/;

$line;
__4fa1a20b30da869cb74ee0ec45b03657

meta::line_filter('convert_sections', <<'__992b5cb95920c73e9ddb83a77e2e305e');
my ($line) = @_;

my %indentation_levels = (
  0 => '\section',
  2 => '\subsection',
  4 => '\subsubsection',
  6 => '\paragraph',
  8 => '\subparagraph');

if ($line =~ /^(\s*)- (.*)$/) {
  my $section = $indentation_levels{length($1)} || die "Invalid indentation level:\n$_";
  my $section_name = $2;
  my $label_name   = lc $section_name;

  $label_name =~ s/[^A-Za-z0-9.]/-/g;

  "${section} {$section_name} \\label{sec:$label_name}";
} else {
  $line;
}
__992b5cb95920c73e9ddb83a77e2e305e

meta::message_color('state', <<'__14e993fdf2c62df353613c243dc9053b');
purple
__14e993fdf2c62df353613c243dc9053b

meta::message_color('states', <<'__152a940086f7cee6110528a09af7dd78');
yellow
__152a940086f7cee6110528a09af7dd78

meta::message_color('watch', <<'__d292ea8fe6dcc812d29610a5a5c09e67');
blue
__d292ea8fe6dcc812d29610a5a5c09e67

meta::section('header-asm', <<'__70388b84ae0ba098cafb4592e3500ac7');
\lstnewenvironment{asmcode} {}{}
__70388b84ae0ba098cafb4592e3500ac7

meta::section('header-cpp', <<'__213aa045c64289eb1ae1128afc284bd7');
\lstnewenvironment{cppcode} {\lstset{language=c++}} {}
__213aa045c64289eb1ae1128afc284bd7

meta::section('header-java', <<'__801fbfea4a00fdfe830a432101d8ed2b');
\lstnewenvironment{javacode}{\lstset{language=java}}{}
__801fbfea4a00fdfe830a432101d8ed2b

meta::section('header-listings', <<'__747e2e3bc83de0d564ec96e91395fa84');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__747e2e3bc83de0d564ec96e91395fa84

meta::section('header-packages', <<'__f69baadb1d3ce11744003b174c91b34b');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__f69baadb1d3ce11744003b174c91b34b

meta::section('header-proof', <<'__ac0f7e79e2127ec3ced94bac981b0db7');
\newenvironmemnt{proof}{\par\noindent\textbf{Proof.}}{\hfill$\square$}
__ac0f7e79e2127ec3ced94bac981b0db7

meta::section('header-refs', <<'__f9c09aef11577a7f9f33af4fffecec89');
\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}
__f9c09aef11577a7f9f33af4fffecec89

meta::section('header-resource', <<'__88678a72c4dfefea8608eab673b009e6');
\lstnewenvironment{resource}{}{}
__88678a72c4dfefea8608eab673b009e6

meta::template('eval', <<'__7be1d470a07a06c58e971bc7fc24c048');
my $result = eval $_[0];
terminal::message('warning', "Error during template evaluation: $@") if $@;
$result;
__7be1d470a07a06c58e971bc7fc24c048

meta::template('failing_conditional', <<'__b49f2ffe1cfefb36b1eabd7abd7b3bb6');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::message('warning', "eval of template condition failed: $@") if $@;
$should_return;
__b49f2ffe1cfefb36b1eabd7abd7b3bb6

meta::template('include', <<'__e0624844a65ae41e0217dd871fc0dbfb');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__e0624844a65ae41e0217dd871fc0dbfb

meta::unlit_converter('create_sections', <<'__24f98c796defbb136930caf99470e6f6');
my ($document) = @_;
1 while $document =~ s/^\s*%section\(([^)]+)\)\s*$/\n$data{$1}\n/omg;
$document;
__24f98c796defbb136930caf99470e6f6

meta::unlit_converter('main', <<'__47d2b6ff6cf4966d2afcecb0885ffedb');
my ($document) = @_;

my $sections_already_encountered = 0;
my $inside_code_block            = 0;
my $code_block_indentation       = 0;
my $code_section_name            = '';
my $result                       = '';

for (split /\n/, $document) {
  # Handle code blocks.
  if (/^(\s*):\.$/) {
    $inside_code_block = $code_block_indentation = 0;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, end => 1);
    }
  }

  if ($inside_code_block) {
    my $spaces_to_delete = ' ' x $code_block_indentation;
    s/^$spaces_to_delete//;
    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation);
    }
  } else {
    for my $filter_name (grep /^line_filter::/, sort keys %data) {
      $_ = &$filter_name($_);
    }
  }

  if (/^(\s*)::(\s.*)?$/) {
    $inside_code_block      = 1;
    $code_block_indentation = length($1);
    $code_section_name      = $2;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, begin => 1);
    }
  }

  $result .= "$_\n";
}

$result;
__47d2b6ff6cf4966d2afcecb0885ffedb

meta::unlit_converter('zz_append_footer', <<'__c0c373358bc6f21231a02e9642758e14');
my ($document) = @_;
"$document\n\\end{document}";
__c0c373358bc6f21231a02e9642758e14

meta::unlit_converter('zz_prepend_header', <<'__07b4a814f2fc777741b399e9adcd93e4');
my ($document) = @_;
header() . "\n$document";
__07b4a814f2fc777741b399e9adcd93e4

meta::vim_highlighter('asmtex', <<'__c0e112849aa77ed93f0e940810436757');
" TeX with Assembly
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with Assembly in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region asmtexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<asm\>.*$/ contains=asmtexSection
syn match  asmtexSection /^\s*- .*$/ contained

runtime! syntax/asm.vim

hi link asmtexSection Special
hi link asmtexComment Comment

let b:current_syntax = "asmtex"
__c0e112849aa77ed93f0e940810436757

meta::vim_highlighter('cltex', <<'__5c6f9e956d9180b8426c07922fec85c1');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match  cltTitle   /^= .*$/
syn match  cltAuthor  /^a .*$/
syn match  cltDate    /^d .*$/
syn match  cltBegin   /^begin$/
syn match  cltSection /^\s*- .*$/
syn region cltVerbatim start=/^\s*::$/ end=/^\s*:\.$/

syn match  cltEnumeratedThing /^\s*[eid]\[/
syn match  cltEnumeratedThing /^\s*\][eid]/
syn match  cltItem            /^\s*+\s/
syn match  cltQuantifiedItem  /^\s*+\[[^\]]*\]\s/

runtime! syntax/tex.vim

syn match  cltInclude /^\s*%section([^)]\+)$/

hi link cltBegin    Keyword
hi link cltTitle    Identifier
hi link cltAuthor   Identifier
hi link cltDate     Identifier

hi link cltEnumeratedThing Special
hi link cltItem            Special
hi link cltQuantifiedItem  Special
hi link cltInclude         Special

hi link cltSection  Type

hi link cltVerbatim String

let b:current_syntax = "cltex"
__5c6f9e956d9180b8426c07922fec85c1

meta::vim_highlighter('cpptex', <<'__bcd26a0f8e5967889360b634ca12af99');
" TeX with C++
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with C++ in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region cpptexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<cpp\>.*$/ contains=cpptexSection
syn match  cpptexSection /^\s*- .*$/ contained

runtime! syntax/cpp.vim

syn match  cpptexInclude /#include\s\+\(\w\|[_()]\)\+/

hi link cpptexSection Special
hi link cpptexComment Comment
hi link cpptexInclude PreProc

let b:current_syntax = "cpptex"
__bcd26a0f8e5967889360b634ca12af99

meta::vim_highlighter('javatex', <<'__31fa5b969d4d736c596e4d3c767396a9');
" TeX with Java
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with Java in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region javatexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<java\>.*$/ contains=javatexSection
syn match  javatexSection /^\s*- .*$/           contained

runtime! syntax/java.vim

hi link javatexSection Special
hi link javatexComment Comment

let b:current_syntax = "javatex"
__31fa5b969d4d736c596e4d3c767396a9

meta::internal('runtime', <<'__487b99b3af6056d1d1c0e00dd4aef707');
my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

END {
  save() unless $initial_state eq state();
}

__487b99b3af6056d1d1c0e00dd4aef707

__END__