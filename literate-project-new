#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

meta::meta('configure', <<'__1a846320e20a15012045d86889c5ac10');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__1a846320e20a15012045d86889c5ac10

meta::meta('externalize', <<'__9c27671cf4a49424bb28ddb62bf44884');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9c27671cf4a49424bb28ddb62bf44884

meta::meta('functor::editable', <<'__63a42d78297d067ca66b2be8838f2a6c');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;
  
  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return preprocess(retrieve($attribute))                                              if $options{preprocess};
      return retrieve($attribute);
    };
  };
}
__63a42d78297d067ca66b2be8838f2a6c

meta::meta('functor::filter', <<'__3dbf72d8ba58053e46acf55854322260');
# Creates a filter type. These are stored in their own namespaces, but are enumerable
# by their attribute names (which match their function names, conveniently).

sub meta::functor::filter {
  my ($typename) = @_;

  meta::configure $typename, extension => '.pl', inherit => 1;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;
    meta::externalize "${typename}::$name", "${typename}::$name", eval "sub{\n$value\n}";
    warn $@ if $@;
  };
}
__3dbf72d8ba58053e46acf55854322260

meta::meta('functor::section', <<'__14120ab07bbf82000b90fc9087f201b8');
sub meta::functor::section {
  my ($typename, %options) = @_;

  meta::configure $typename, %options, inherit => 0;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;
    meta::externalize $name, "${typename}::$name", sub {
      edit("${typename}::$name");
    };
  };
}
__14120ab07bbf82000b90fc9087f201b8

meta::meta('internal::runtime', <<'__43c46ff6344bc04d6dbac7f43c77ad30');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__43c46ff6344bc04d6dbac7f43c77ad30

meta::meta('type::asm_section', <<'__7aab5ca8d3abe498b0abf6c856f73238');
meta::functor::section 'asm_section', extension => '.asmtex';
__7aab5ca8d3abe498b0abf6c856f73238

meta::meta('type::bootstrap', <<'__74115c281ce77668fcad6f14010b1478');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__74115c281ce77668fcad6f14010b1478

meta::meta('type::code_filter', <<'__3fb054f81002f800885ab3ec2075d09e');
meta::functor::filter 'code_filter';
__3fb054f81002f800885ab3ec2075d09e

meta::meta('type::cpp_section', <<'__7aab5ca8d3abe498b0abf6c856f73238');
meta::functor::section 'cpp_section', extension => '.cpptex';
__7aab5ca8d3abe498b0abf6c856f73238

meta::meta('type::data', <<'__29845b326633c6f0bc9b197c84802724');
meta::functor::editable 'data', extension => '', inherit => 0, default => 'cat';
__29845b326633c6f0bc9b197c84802724

meta::meta('type::function', <<'__8d6854866c9e4b2e790f9d8cb0faefd8');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__8d6854866c9e4b2e790f9d8cb0faefd8

meta::meta('type::internal_function', <<'__55005008fd5a1a7005b2b120b9e427f4');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  warn $@ if $@;
};
__55005008fd5a1a7005b2b120b9e427f4

meta::meta('type::java_section', <<'__79ef66b436d856183863d5e89cc40df8');
meta::functor::section 'java_section', extension => '.javatex';
__79ef66b436d856183863d5e89cc40df8

meta::meta('type::library', <<'__1b159400ac08a2880bb5aaec79b7c3d8');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;

  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__1b159400ac08a2880bb5aaec79b7c3d8

meta::meta('type::line_filter', <<'__3fb054f81002f800885ab3ec2075d09e');
meta::functor::filter 'line_filter';
__3fb054f81002f800885ab3ec2075d09e

meta::meta('type::message_color', <<'__b4a10ed3fecf36b03d7c04b91922d69d');
meta::functor::editable 'message_color', extension => '', inherit => 1, default => 'cat', on_bind => sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__b4a10ed3fecf36b03d7c04b91922d69d

meta::meta('type::meta', <<'__9271aa927322e2488587d8f096adcbb0');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__9271aa927322e2488587d8f096adcbb0

meta::meta('type::note', <<'__31d70ad8e7a4f0409a1208500bedfb3e');
meta::functor::editable 'note', extension => '', inherit => 0, default => 'edit';
__31d70ad8e7a4f0409a1208500bedfb3e

meta::meta('type::section', <<'__a78528a0e7aaa2c8d114c42adae348ec');
meta::functor::section 'section', extension => '.cltex';
__a78528a0e7aaa2c8d114c42adae348ec

meta::meta('type::template', <<'__214fed209a6433a640f50f22fe8dc970');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__214fed209a6433a640f50f22fe8dc970

meta::meta('type::unlit_converter', <<'__818f2dd804e75b20b78d2108f083e7f0');
meta::functor::filter 'unlit_converter';
__818f2dd804e75b20b78d2108f083e7f0

meta::meta('type::vim_highlighter', <<'__901a140fbc881c900779dc4085b2efe8');
meta::functor::editable 'vim_highlighter', extension => '.vim', inherit => 1, default => 'edit';
__901a140fbc881c900779dc4085b2efe8

meta::meta('type::watch', <<'__45620986307f4448226fed5034a9ee48');
meta::functor::editable 'watch', prefix => 'watch::', inherit => 1, extension => '.pl', default => 'cat';
__45620986307f4448226fed5034a9ee48

meta::asm_section('asm-introduction', <<'__9537417c735b2a80e09f09d2015ea5bb');
- Introduction to Assembly Literate Coding
  Assembly-language snippets are specified in much the same way as C++ snippets. The only difference is that the \verb|asm| marker is used instead of \verb|cpp|.

  :: asm name=test.s
  main:
    movl $1, %eax
    ret
  :.
__9537417c735b2a80e09f09d2015ea5bb

meta::bootstrap('initialization', <<'__bb61c08f3f1cb340417ab4984db3f408');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

__bb61c08f3f1cb340417ab4984db3f408

meta::code_filter('asm', <<'__06365bc795880998a1434a2480fb8298');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sasm(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{asmcode}" if $settings{'begin'};
  } else {
    return '\begin{asmcode}' if $settings{'begin'};
  }

  return '\end{asmcode}' if $settings{'end'};
}

return $line;
__06365bc795880998a1434a2480fb8298

meta::code_filter('cpp', <<'__06365bc795880998a1434a2480fb8298');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\scpp(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{cppcode}" if $settings{'begin'};
  } else {
    return '\begin{cppcode}' if $settings{'begin'};
  }

  return '\end{cppcode}' if $settings{'end'};
}

return $line;
__06365bc795880998a1434a2480fb8298

meta::code_filter('java', <<'__a898a58c99e4e7a0313014c8af5c06e7');
use File::Path 'mkpath';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sjava(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if ($properties{'class'}) {
    my $classname         = $properties{'class'};
    my $package_directory = $properties{'package'};
    $package_directory =~ tr[.][/];

    mkpath(my $directory = &{'source-directory'}() . '/' . $package_directory);
    open my $fh, $settings{'begin'} ? '>' : '>>', "$directory/${classname}.java";
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$properties{package}.$properties{class}}\n\\begin{javacode}" if $settings{'begin'};
  }

  return '\begin{javacode}' if $settings{'begin'};
  return '\end{javacode}'   if $settings{'end'};
}

return $line;
__a898a58c99e4e7a0313014c8af5c06e7

meta::code_filter('resource', <<'__70deee6ce78c87e00251f7315cd0e24c');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sresource(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{resource}" if $settings{'begin'};
  } else {
    return '\begin{resource}' if $settings{'begin'};
  }

  return '\end{resource}' if $settings{'end'};
}

return $line;
__70deee6ce78c87e00251f7315cd0e24c

meta::code_filter('verbatim', <<'__dce639b8c4dd4d28f3f2776e39f936d1');
my ($line, %settings) = @_;

unless ($settings{'name'}) {
  return '\begin{verbatim}' if $settings{'begin'};
  return '\end{verbatim}'   if $settings{'end'};
}

return $line;
__dce639b8c4dd4d28f3f2776e39f936d1

meta::cpp_section('cpp-introduction', <<'__d28a4c501cd8ceda32f7126b14a1165c');
- Introduction to C++ Literate Coding
  The C++ literate code interface is much like the Java one, except that code sections use the \verb|name=x| attribute rather than \verb|class=| and \verb|package=|. The name is expected to
  include an extension, so for example \verb|:: cpp name=src/foo.h| is a correct heading.

  :: cpp name=hello.cc
  #include<iostream>
  int main () {
    std::cout << "Hello world!" << std::endl;
  }
  :.
__d28a4c501cd8ceda32f7126b14a1165c

meta::data('default-action', <<'__6d9df52ac01d067015f07a921b7feb16');
shell
__6d9df52ac01d067015f07a921b7feb16

meta::data('license', <<'__f2cf09fcaa44be7888c870b09d1cfb0e');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__f2cf09fcaa44be7888c870b09d1cfb0e

meta::data('name', <<'__7f26c2f3b6ca211465988330aca2884c');
literate-project
__7f26c2f3b6ca211465988330aca2884c

meta::data('quiet', <<'__ca6cb8e4873598e00c4d4978e9557570');
1
__ca6cb8e4873598e00c4d4978e9557570

meta::function('add-to', <<'__1b0e0b90580dc73056412630d3601450');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__1b0e0b90580dc73056412630d3601450

meta::function('cat', <<'__b66d44d61aab902c56d5c808464e99e0');
my ($name) = @_;
$data{$name};
__b66d44d61aab902c56d5c808464e99e0

meta::function('clone', <<'__9cf4ea7db26e6e70bc1a496af9774380');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__9cf4ea7db26e6e70bc1a496af9774380

meta::function('cp', <<'__e9a1194816a7f6c36bc518de45aa06c8');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__e9a1194816a7f6c36bc518de45aa06c8

meta::function('create', <<'__3635039812e83a384cadd7e81bf4805b');
my ($name, $value) = @_;

messages::error("Attribute $name already exists.") if grep $_ eq $name, keys %data;
if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__3635039812e83a384cadd7e81bf4805b

meta::function('edit', <<'__e148f15260a169549bb9faf888b89e2e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__e148f15260a169549bb9faf888b89e2e

meta::function('exists', <<'__a29981f8bc269718a126bdb4ba00cdfe');
my $name = shift;
grep {$_ eq $name} keys %data;
__a29981f8bc269718a126bdb4ba00cdfe

meta::function('export', <<'__c750d5e8911eea5289c09687f0987f68');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  messages::error("Not enough arguments");
}
__c750d5e8911eea5289c09687f0987f68

meta::function('grab', <<'__9e9dc7c0a02379a481e2d16079e47528');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__9e9dc7c0a02379a481e2d16079e47528

meta::function('hash', <<'__9a26de7e7cbb9218461779d8daf79002');
my ($data) = @_;
fast_hash($data);
__9a26de7e7cbb9218461779d8daf79002

meta::function('import', <<'__6b465b501ed2e590742c9538a51add80');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__6b465b501ed2e590742c9538a51add80

meta::function('import-bundle', <<'__87c31c42c0ebfe3471bac28857efc764');
eval join '', <STDIN>;
messages::error($@) if $@;
__87c31c42c0ebfe3471bac28857efc764

meta::function('lock', <<'__224b5b38a80ec0bef8afba786b1b876e');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__224b5b38a80ec0bef8afba786b1b876e

meta::function('ls', <<'__c7788eadd6a7d11406ea840cc11c5df0');
my $criteria = join '|', @_;
my @lines = grep /$criteria/ && defined $data{$externalized_functions{$_}}, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__c7788eadd6a7d11406ea840cc11c5df0

meta::function('ls-a', <<'__9b51b6802023c3f85e083b18ee0e66e8');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . sprintf('%6d  ', length(serialize_single($_))) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__9b51b6802023c3f85e083b18ee0e66e8

meta::function('mv', <<'__831188a8239540b0722a2648073d6a88');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

return messages::error("'$from' does not exist.") unless grep $from, keys %data;
return messages::error("The namepsace '$destination_namespace' does not exist") unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__831188a8239540b0722a2648073d6a88

meta::function('perl', <<'__e3ecc4a2e342a050208374f08e9cf9e8');
my $result = eval($_[0]);
$@ ? $@ : $result;
__e3ecc4a2e342a050208374f08e9cf9e8

meta::function('pop-state', <<'__e3eae3b3420ae5686c99ba78c85b6688');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__e3eae3b3420ae5686c99ba78c85b6688

meta::function('preprocess', <<'__1f2fe68a8b74b100e352b88b0f80a260');
# Implements a simple preprocessing language. Directives are functions:

# = function [arguments...]
# Each function can be supplied with one or more arguments. These are mapped straight
# into the function's argument list.

# This syntax is deliberately not very flexible. You shouldn't be using complex
# expressions for these things. The beginning delimiter must be preceded by either
# nothing or only whitespace. By default it is =, but that can be changed.

# Template functions are defined by creating template:: attributes.

my ($string, %options) = @_;
my $delimiter          = $options{delimiter} || '=';

1 while $string =~ s/^\s*$delimiter\s+([^\s]+)\s*(.*)$/${\(&{"template::$1"}($2))}/omg;

$string;
__1f2fe68a8b74b100e352b88b0f80a260

meta::function('pull', <<'__20174170a253f060e408d8d38242aa0a');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__20174170a253f060e408d8d38242aa0a

meta::function('push-state', <<'__8f5cf6d01bef7e78452bf9a0e11554b0');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__8f5cf6d01bef7e78452bf9a0e11554b0

meta::function('reload', <<'__8927d97fc280e7c8f2e4f30865fd9430');
execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;
__8927d97fc280e7c8f2e4f30865fd9430

meta::function('rm', <<'__e9ba58a4f738c1082e8434c865fe405c');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__e9ba58a4f738c1082e8434c865fe405c

meta::function('save', <<'__0895b63cde6880a8f302a24c1adb4e38');
if (! verify()) {
  messages::error("$0 has not been updated.");
} else {
  my $serialized_data = serialize();
  eval {file::write($0, $serialized_data)};
  messages::error($@) if $@;
  terminal::message('info', "$0 saved successfully.");
}
__0895b63cde6880a8f302a24c1adb4e38

meta::function('serialize', <<'__c0d0324cdb78b5a04a7c4c40e68356b8');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && (! $criteria || m/$criteria/), sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;
__c0d0324cdb78b5a04a7c4c40e68356b8

meta::function('serialize_single', <<'__508b57e07401be981bd0b62578eb97ea');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $delimiter          = '__' . fast_hash($contents);
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename($name);

return "$meta_function_name('$invocation_name', '$contents');"   if $contents =~ /^[^\n']*$/;
return "$meta_function_name('$invocation_name', \"$contents\");" if $contents =~ /^[^\n"\\\$@%&]*$/;
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__508b57e07401be981bd0b62578eb97ea

meta::function('shell', <<'__13e833a0a63dc4188c35d5f40a527444');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $output = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';
  associate('data::watching', 0, execute => 1), next if $function_name eq 'disable-watch';
  associate('data::watching', 1, execute => 1), next if $function_name eq 'enable-watch';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      chomp(my $result = eval {&$function_name(@args)});
      messages::warning($@) if $@;
      print $output $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  if (watching()) {
    for my $watch (map retrieve($_), grep /^watch::/, sort keys %data) {
      terminal::message('watch',   "$watch => " . eval($watch));
      terminal::message('warning', "Error evaluating watched expression $watch: $@") if $@;
    }
  }

  $prompt = name() . '$ ';
}
__13e833a0a63dc4188c35d5f40a527444

meta::function('size', <<'__6635b94868b03862a4580cb0a8b8f220');
length(serialize());
__6635b94868b03862a4580cb0a8b8f220

meta::function('snapshot', <<'__ca1cda4868e39e9c41656c684c693a38');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('info', "Created snapshot at $finalname.");
__ca1cda4868e39e9c41656c684c693a38

meta::function('state', <<'__4d034648fee627b00dd6369e2a4c3c71');
fast_hash(serialize());
__4d034648fee627b00dd6369e2a4c3c71

meta::function('unlock', <<'__224b5b38a80ec0bef8afba786b1b876e');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__224b5b38a80ec0bef8afba786b1b876e

meta::function('update-from', <<'__c861fe082e19426485774582aae8a124');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.

my $target  = $_[0] or die 'Must specify another script to pull data from.';
my @options = grep /^-/, @_;

terminal::message('info', 'Replicating state...');
&{'push-state'}();

terminal::message('info', 'Updating meta attributes...');
eval qx($target serialize '^meta::');
terminal::message('warning', $@) if $@;
terminal::message('warning', 'One of the meta-attributes triggered a verification failure.') unless verify();

terminal::message('info', 'Updating non-meta attributes...');
my $combined_pattern = join '|', map "^${_}::", grep ! (/^meta$/ || /^internal$/) && $transient{inherit}{$_}, sort keys %{$transient{inherit}};
eval qx($target serialize '$combined_pattern');
terminal::message('warning', $@) if $@;
reload();

if (verify()) {
  terminal::message('info', "Successfully updated from $_[0]. Run pop-state to undo this change.");
} elsif (grep /^--force$/o || /^-f$/o, @options) {
  terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
  terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
  terminal::message('info',    'Run pop-state to undo the update and return to a working state.');
} else {
  terminal::message('error', 'Verification failed after the upgrade was complete.');
  terminal::message('info',  "$0 has been reverted to its pre-upgrade state.");
  terminal::message('info',  "If you want to upgrade and keep the failure state, then run update-from $target --force.");
  &{'pop-state'}();
}
__c861fe082e19426485774582aae8a124

meta::function('usage', <<'__0be43bc0509e2668c1917dd8878f505e');
<<"EOD" . ls ();
Usage: $0 action [arguments]
Defined actions (and the attribute that defines them):
EOD
__0be43bc0509e2668c1917dd8878f505e

meta::function('verify', <<'__a9f34f105cf9d1904869e5f0ca8fdfd8');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;
unlink $temporary_filename if $result;
$transient{temporary_filename} = $temporary_filename;

$result;
__a9f34f105cf9d1904869e5f0ca8fdfd8

meta::function('vim', <<'__edb40adffe36f0e89f1392606c67d108');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__edb40adffe36f0e89f1392606c67d108

meta::internal_function('associate', <<'__8d6854866c9e4b2e790f9d8cb0faefd8');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__8d6854866c9e4b2e790f9d8cb0faefd8

meta::internal_function('basename', <<'__90dcfe980f60186ca73eb5804e33e940');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__90dcfe980f60186ca73eb5804e33e940

meta::internal_function('complete', <<'__17b92f0ce1c662fc29fac1081005d3d0');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__17b92f0ce1c662fc29fac1081005d3d0

meta::internal_function('execute', <<'__e7f72ae8f9f8be3587da26d042445a60');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__e7f72ae8f9f8be3587da26d042445a60

meta::internal_function('fast_hash', <<'__1402f938bb3f9c8c55813f66a01f7640');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = substr($data, $piece_size * 8) . length($data), map substr($data, $piece_size * $_, $piece_size), 0 .. 7;
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__1402f938bb3f9c8c55813f66a01f7640

meta::internal_function('file::read', <<'__0be43bc0509e2668c1917dd8878f505e');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__0be43bc0509e2668c1917dd8878f505e

meta::internal_function('file::write', <<'__026bac5614aee674d5ad9a341d2c4be8');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__026bac5614aee674d5ad9a341d2c4be8

meta::internal_function('fnv_hash', <<'__94ebec78c1fe9bc80e4f6e2c70c4c488');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

(($hash ^= $_) *= $fnv_prime) %= $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__94ebec78c1fe9bc80e4f6e2c70c4c488

meta::internal_function('invoke_editor_on', <<'__c810c120392b0de0a77ab8c81a8c67b8');
my ($data, %options) = @_;
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my $filename         = temporary_name() . $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__c810c120392b0de0a77ab8c81a8c67b8

meta::internal_function('messages::error', <<'__27e50d66ebfd1be4f31f3b489824ceb0');
my ($message) = @_;
terminal::message('error', $message);
die;
__27e50d66ebfd1be4f31f3b489824ceb0

meta::internal_function('messages::warning', <<'__70c4dfe31e4a0a80679722e0424397f4');
my ($message) = @_;
terminal::message('warning', $message);
__70c4dfe31e4a0a80679722e0424397f4

meta::internal_function('namespace', <<'__e2799868bca51600b966845038cc7eb8');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__e2799868bca51600b966845038cc7eb8

meta::internal_function('retrieve', <<'__cc601f4f737cf3b087fba3743eba8e68');
@data{@_};
__cc601f4f737cf3b087fba3743eba8e68

meta::internal_function('serialize_single', <<'__45b813708c43e9d0086f88e092d9dc80');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = '__' . fast_hash($contents);
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__45b813708c43e9d0086f88e092d9dc80

meta::internal_function('state_based_filename', <<'__29845b326633c6f0bc9b197c84802724');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__29845b326633c6f0bc9b197c84802724

meta::internal_function('temporary_name', <<'__fe8eb68ec4d017b42020e454b0dc0140');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
$temporary_filename;
__fe8eb68ec4d017b42020e454b0dc0140

meta::java_section('java-introduction', <<'__5fa47088e3d41a48dce9554848383c54');
- Introduction to Java Literate Coding
  Literate coding allows you to write \TeX{} primarily, but insert Java code snippets where appropriate.\footnote{Take a look at {\tt java\_section::java-introduction} to see the how to set
  the language and options for code sections.} For example:

  :: java class=test
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is a test class");
    }
  }
  :.

  :: java class=test package=com.spencertipping
  package com.spencertipping;
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is in package com.spencertipping.");
    }
  }
  :.

  Compiling the system is also simple:

  ::
  $ ./my-project compile
  :.

  This generates all of the Java source files in a directory, usually {\tt /tmp/src/}. The output directory can be changed like this:

  ::
  $ ./my-project source-directory = src/
  :.
__5fa47088e3d41a48dce9554848383c54

meta::library('terminal', <<'__70c9d8000de819600ec004e0f7eda840');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color   'debug',   'blue';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__70c9d8000de819600ec004e0f7eda840

meta::line_filter('convert_header_info', <<'__f32fbe1c62af17a8b6638bc2c1c55397');
my ($line) = @_;

$line =~ s/^= (.*)$/\\title{$1}/;
$line =~ s/^a (.*)$/\\author{$1}/;
$line =~ s/^d (.*)$/\\date{$1}/;

my $document_header = '\begin{document}\maketitle';
$document_header .= '\tableofcontents' if &{'table-of-contents'}();

$line =~ s/^begin$/$document_header/;

$line;
__f32fbe1c62af17a8b6638bc2c1c55397

meta::line_filter('convert_itemized_environments', <<'__ad9b8a187dd4f91037681ef8d7e5e476');
my ($line) = @_;

$line =~ s/^\s*\+ /\\item /;
$line =~ s/^\s*\+\[([^\]]*)\] /\\item[\1] /;

$line =~ s/^\s*e\[$/\\begin{enumerate}/;
$line =~ s/^\s*i\[$/\\begin{itemize}/;
$line =~ s/^\s*d\[$/\\begin{description}/;

$line =~ s/^\s*a\[$/\\begin{align*}/;

$line =~ s/^\s*\]e$/\\end{enumerate}/;
$line =~ s/^\s*\]i$/\\end{itemize}/;
$line =~ s/^\s*\]d$/\\end{description}/;

$line =~ s/^\s*\]a$/\\end{align*}/;

$line;
__ad9b8a187dd4f91037681ef8d7e5e476

meta::line_filter('convert_sections', <<'__ca3e0a887e662212c2e7f56e76f331ac');
my ($line) = @_;

my %indentation_levels = (
  0 => '\section',
  2 => '\subsection',
  4 => '\subsubsection',
  6 => '\paragraph',
  8 => '\subparagraph');

if ($line =~ /^(\s*)- (.*)$/) {
  my $section = $indentation_levels{length($1)} || die "Invalid indentation level:\n$_";
  my $section_name = $2;
  my $label_name   = lc $section_name;

  $label_name =~ s/[^A-Za-z0-9.]/-/g;

  "${section} {$section_name} \\label{sec:$label_name}";
} else {
  $line;
}
__ca3e0a887e662212c2e7f56e76f331ac

meta::message_color('watch', <<'__bcacab10df2b159c8230b4c8d13704e4');
blue
__bcacab10df2b159c8230b4c8d13704e4

meta::section('header-asm', <<'__48ca68a1ec3ce1a0399975aa59491dc8');
\lstnewenvironment{asmcode} {}{}
__48ca68a1ec3ce1a0399975aa59491dc8

meta::section('header-cpp', <<'__37635ca040e96a10803a45d124f16354');
\lstnewenvironment{cppcode} {\lstset{language=c++}} {}
__37635ca040e96a10803a45d124f16354

meta::section('header-java', <<'__78fcc3f2952012d6ffca5188d5c95546');
\lstnewenvironment{javacode}{\lstset{language=java}}{}
__78fcc3f2952012d6ffca5188d5c95546

meta::section('header-listings', <<'__30ca66581ae6eb885f467a98a93e5d98');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__30ca66581ae6eb885f467a98a93e5d98

meta::section('header-packages', <<'__02e315b0fd8f62908484c888fd805894');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__02e315b0fd8f62908484c888fd805894

meta::section('header-proof', <<'__d0d51558475dc3e83e80c1f661a171d0');
\newenvironmemnt{proof}{\par\noindent\textbf{Proof.}}{\hfill$\square$}
__d0d51558475dc3e83e80c1f661a171d0

meta::section('header-refs', <<'__37f9ad58210c0c40749456b8b09aa920');
\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}
__37f9ad58210c0c40749456b8b09aa920

meta::section('header-resource', <<'__48ca68a1ec3ce1a0399975aa59491dc8');
\lstnewenvironment{resource}{}{}
__48ca68a1ec3ce1a0399975aa59491dc8

meta::template('eval', <<'__343833f4d436a0e4857bb09e8fac9c70');
my $result = eval $_[0];
terminal::message('warning', "Error during template evaluation: $@") if $@;
$result;
__343833f4d436a0e4857bb09e8fac9c70

meta::template('failing_conditional', <<'__431dd76cd40ff4640383f298022c6ff0');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::message('warning', "eval of template condition failed: $@") if $@;
$should_return;
__431dd76cd40ff4640383f298022c6ff0

meta::template('include', <<'__140ecc14c0fbedf85b3567d8a0a605a0');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__140ecc14c0fbedf85b3567d8a0a605a0

meta::unlit_converter('create_sections', <<'__887cf5f8347d69909de892d0de04018c');
my ($document) = @_;
1 while $document =~ s/^\s*%section\(([^)]+)\)\s*$/\n$data{$1}\n/omg;
$document;
__887cf5f8347d69909de892d0de04018c

meta::unlit_converter('main', <<'__b82281fec91840907577aa00cc827e90');
my ($document) = @_;

my $sections_already_encountered = 0;
my $inside_code_block            = 0;
my $code_block_indentation       = 0;
my $code_section_name            = '';
my $result                       = '';

for (split /\n/, $document) {
  # Handle code blocks.
  if (/^(\s*):\.$/) {
    $inside_code_block = $code_block_indentation = 0;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, end => 1);
    }
  }

  if ($inside_code_block) {
    my $spaces_to_delete = ' ' x $code_block_indentation;
    s/^$spaces_to_delete//;
    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation);
    }
  } else {
    for my $filter_name (grep /^line_filter::/, sort keys %data) {
      $_ = &$filter_name($_);
    }
  }

  if (/^(\s*)::(\s.*)?$/) {
    $inside_code_block      = 1;
    $code_block_indentation = length($1);
    $code_section_name      = $2;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, begin => 1);
    }
  }

  $result .= "$_\n";
}

$result;
__b82281fec91840907577aa00cc827e90

meta::unlit_converter('zz_append_footer', <<'__9fefde0c11a676d039f742207e95f896');
my ($document) = @_;
"$document\n\\end{document}";
__9fefde0c11a676d039f742207e95f896

meta::unlit_converter('zz_prepend_header', <<'__b44d2b1a2eacf6089c6010485e11757a');
my ($document) = @_;
header() . "\n$document";
__b44d2b1a2eacf6089c6010485e11757a

meta::internal('runtime', <<'__1bfa2e039e12f9a859960eb496e499ca');
my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

END {
  save() unless $initial_state eq state();
}

__1bfa2e039e12f9a859960eb496e499ca

__END__