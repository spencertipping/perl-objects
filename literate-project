#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('configure', <<'__eef2c1281aa263312688eaa0bf3f2f68390d0827');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__eef2c1281aa263312688eaa0bf3f2f68390d0827

meta::meta('datatypes::asm_section', <<'__b1d3cef0d2190780ab01c4a8801afad0f6f78ef0');
meta::define_form 'asm_section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "asm_section::$name";
  *{$name} = sub {
    edit("asm_section::$name");
  };
};
__b1d3cef0d2190780ab01c4a8801afad0f6f78ef0

meta::meta('datatypes::bootstrap', <<'__5de13e28b13a75348b144c5402d2c8e4070a33dc');
meta::define_form 'bootstrap', sub {};
__5de13e28b13a75348b144c5402d2c8e4070a33dc

meta::meta('datatypes::code_filter', <<'__c23e10a8e8ff80503f0a9e5ccadc60b0d745b0c0');
meta::define_form 'code_filter', sub {
  my ($name, $value) = @_;
  *{"code_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__c23e10a8e8ff80503f0a9e5ccadc60b0d745b0c0

meta::meta('datatypes::cpp_section', <<'__113186b8fae5a808f15707442f0a934863c2558c');
meta::define_form 'cpp_section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "cpp_section::$name";
  *{$name} = sub {
    edit("cpp_section::$name");
  };
};
__113186b8fae5a808f15707442f0a934863c2558c

meta::meta('datatypes::data', <<'__728b10b0dda67e84391c3b04529e4d6cffb303e8');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("data::$name")                                  if $_[0] eq 'edit';
    retrieve("data::$name");
  };
};
__728b10b0dda67e84391c3b04529e4d6cffb303e8

meta::meta('datatypes::function', <<'__bee70500e8bdff5ced5db6e4e41ac8c8fe4f1900');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__bee70500e8bdff5ced5db6e4e41ac8c8fe4f1900

meta::meta('datatypes::internal_function', <<'__ce845f487837a2f819952650b26095f4fb79dd2a');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__ce845f487837a2f819952650b26095f4fb79dd2a

meta::meta('datatypes::java_section', <<'__aa9990c06cc20f48f4680d7800fc7e5c5dc42018');
meta::define_form 'java_section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "java_section::$name";
  *{$name} = sub {
    edit("java_section::$name");
  };
};
__aa9990c06cc20f48f4680d7800fc7e5c5dc42018

meta::meta('datatypes::library', <<'__0e733a20fd7207a4bcb901b09d3372f04729dd88');
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  $externalized_functions{$name} = "library::$name";
  *{$name} = sub {edit("library::$name")};
  warn $@ if $@;
};
__0e733a20fd7207a4bcb901b09d3372f04729dd88

meta::meta('datatypes::line_filter', <<'__e9b6f7e869c133880c225ee40019f34841eb6ba0');
meta::define_form 'line_filter', sub {
  my ($name, $value) = @_;
  *{"line_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__e9b6f7e869c133880c225ee40019f34841eb6ba0

meta::meta('datatypes::list-type', <<'__b7b8af4c5a5b9b00a6f8aa58e236b16c5fd3874c');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__b7b8af4c5a5b9b00a6f8aa58e236b16c5fd3874c

meta::meta('datatypes::message-color', <<'__6023be8c80f207d83a73416c42a2d110b6b5eecc');
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "message_color::$name";
  terminal::color($name, $value);
  *{$name} = sub {
    associate("message_color::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("message_color::$name")                                  if $_[0] eq 'edit';
    retrieve("message_color::$name");
  };
};
__6023be8c80f207d83a73416c42a2d110b6b5eecc

meta::meta('datatypes::note', <<'__9b5cd0288960482807628dd8e0445382db8b5210');
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__9b5cd0288960482807628dd8e0445382db8b5210

meta::meta('datatypes::section', <<'__e7eb96a01f4307f0223833acf8c5f330ef07e108');
meta::define_form 'section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "section::$name";
  *{$name} = sub {
    edit("section::$name");
  };
};
__e7eb96a01f4307f0223833acf8c5f330ef07e108

meta::meta('datatypes::unlit_converter', <<'__968811d0de835080cde4a48318abd6e7a134933e');
meta::define_form 'unlit_converter', sub {
  my ($name, $value) = @_;
  *{"unlit_converter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__968811d0de835080cde4a48318abd6e7a134933e

meta::meta('datatypes::vim-highlighter', <<'__d62ba8a830b689aaffc59f555a65fd28eb3f7dd0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__d62ba8a830b689aaffc59f555a65fd28eb3f7dd0

meta::meta('externalize', <<'__c80794c0f2d6e2884caa7e6a780f6bf17de1b470');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__c80794c0f2d6e2884caa7e6a780f6bf17de1b470

meta::meta('internal::runtime', <<'__8e8cc66f6a9977507d211918b65cbfba78e814ea');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__8e8cc66f6a9977507d211918b65cbfba78e814ea

meta::meta('type::bootstrap', <<'__76b8f680d46687c639143238fec5e33429ea2a80');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__76b8f680d46687c639143238fec5e33429ea2a80

meta::meta('type::data', <<'__53c2fa38577a7e80eaacdada3a786992406c6f40');
meta::configure 'data', extension => '', inherit => 0;
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  meta::externalize $name, "data::$name", sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("data::$name")                                  if $_[0] eq 'edit';
    retrieve("data::$name");
  };
};
__53c2fa38577a7e80eaacdada3a786992406c6f40

meta::meta('type::function', <<'__cb9c838848345106e4dd83f120e884243ebfea68');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__cb9c838848345106e4dd83f120e884243ebfea68

meta::meta('type::internal_function', <<'__581839c4aa38453088de1f6c734e28284f336088');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  warn $@ if $@;
};
__581839c4aa38453088de1f6c734e28284f336088

meta::meta('type::library', <<'__5f879740b47b2a48430b0a34cdf1b4f013c389a0');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  $externalized_functions{$name} = "library::$name";
  *{$name} = sub {edit("library::$name")};
  warn $@ if $@;
};
__5f879740b47b2a48430b0a34cdf1b4f013c389a0

meta::meta('type::message_color', <<'__4091dd406919aaa054897c70e7d187a81e0b6a68');
meta::configure 'message_color', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "message_color::$name";
  terminal::color($name, $value);
  *{$name} = sub {
    associate("message_color::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("message_color::$name")                                  if $_[0] eq 'edit';
    retrieve("message_color::$name");
  };
};
__4091dd406919aaa054897c70e7d187a81e0b6a68

meta::meta('type::meta', <<'__7d9446b8ef4af840e5bca1e475376638dcdf1b68');
meta::configure 'meta', extension => '.pl', inherit => 1;
__7d9446b8ef4af840e5bca1e475376638dcdf1b68

meta::meta('type::note', <<'__5ec26340c37fc180a1f9f607559639b08db73608');
meta::configure 'note', inherit => 0;
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__5ec26340c37fc180a1f9f607559639b08db73608

meta::meta('type::vim_highlighter', <<'__7d47c7cc891f6d30ab57f964247637a023723ca6');
meta::configure 'vim_highlighter', extension => '.vim', inherit => 1;
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__7d47c7cc891f6d30ab57f964247637a023723ca6

meta::_list_type('list', <<'__0b27c4057f19ced02b9dd5049e78f02a912922f0');
list
__0b27c4057f19ced02b9dd5049e78f02a912922f0

meta::asm_section('asm-introduction', <<'__4e5faf6582ed39682b003d2c04c3a2a042cfc5d0');
- Introduction to Assembly Literate Coding
  Assembly-language snippets are specified in much the same way as C++ snippets. The only difference is that the \verb|asm| marker is used instead of \verb|cpp|.

  :: asm name=test.s
  main:
    movl $1, %eax
    ret
  :.
__4e5faf6582ed39682b003d2c04c3a2a042cfc5d0

meta::bootstrap('initialization', <<'__8c901310353562a01a2ed67e5933447c8af23050');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__8c901310353562a01a2ed67e5933447c8af23050

meta::bootstrap('pod', <<'__fc19db6676875b18d8747cc1f9869f28c5ccf310');

=head1 NAME

object - Stateful file-based object

=head1 SYNOPSYS

object [options] action [arguments...]

object shell

=head1 DESCRIPTION

Stateful objects preserve their state between executions by rewriting themselves. Each time the script exits it replaces its contents with its new state. Thus
state management, for user-writable scripts, is completely transparent.

An object rewrites itself only if its state has changed. This may seem like a dangerous operation, but some checks are put into place to ensure that it goes
smoothly. First, the object is initially written to a separate file. Next, that file is executed and asked to provide a hashsum of its contents. The original
object is rewritten only if that hashsum is correct. This ensures that the replacement object is functional and has the right data.

Currently the only known way to lose your data is to edit the serialization-related functions in such a way that they no longer function. However, this is not
something most people will normally do. In the future there may be a locking mechanism to prevent unintentional edits of these attributes.

=cut
__fc19db6676875b18d8747cc1f9869f28c5ccf310

meta::code_filter('cpp', <<'__f33778bcd9ed93a8f13b4ac05310126ca156a6ec');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\scpp(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{cppcode}" if $settings{'begin'};
  } else {
    return '\begin{cppcode}' if $settings{'begin'};
  }

  return '\end{cppcode}' if $settings{'end'};
}

return $line;
__f33778bcd9ed93a8f13b4ac05310126ca156a6ec

meta::code_filter('java', <<'__75428536b2b3d1144797953874b792808b2b8e80');
use File::Path 'mkpath';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sjava(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if ($properties{'class'}) {
    my $classname         = $properties{'class'};
    my $package_directory = $properties{'package'};
    $package_directory =~ tr[.][/];

    mkpath(my $directory = &{'source-directory'}() . '/' . $package_directory);
    open my $fh, $settings{'begin'} ? '>' : '>>', "$directory/${classname}.java";
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$properties{package}.$properties{class}}\n\\begin{javacode}" if $settings{'begin'};
  }

  return '\begin{javacode}' if $settings{'begin'};
  return '\end{javacode}'   if $settings{'end'};
}

return $line;
__75428536b2b3d1144797953874b792808b2b8e80

meta::code_filter('resource', <<'__868ae08007546e6baa413f60d98d87f810de542e');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sresource(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{resource}" if $settings{'begin'};
  } else {
    return '\begin{resource}' if $settings{'begin'};
  }

  return '\end{resource}' if $settings{'end'};
}

return $line;
__868ae08007546e6baa413f60d98d87f810de542e

meta::code_filter('verbatim', <<'__5dd84ef062d4c490247f4208b5dfa4765b4657f8');
my ($line, %settings) = @_;

unless ($settings{'name'}) {
  return '\begin{verbatim}' if $settings{'begin'};
  return '\end{verbatim}'   if $settings{'end'};
}

return $line;
__5dd84ef062d4c490247f4208b5dfa4765b4657f8

meta::cpp_section('cpp-introduction', <<'__76d2d07c70dbfc1491ed3e38f7e93c8309467b2c');
- Introduction to C++ Literate Coding
  The C++ literate code interface is much like the Java one, except that code sections use the \verb|name=x| attribute rather than \verb|class=| and \verb|package=|. The name is expected to
  include an extension, so for example \verb|:: cpp name=src/foo.h| is a correct heading.

  :: cpp name=hello.cc
  #include<iostream>
  int main () {
    std::cout << "Hello world!" << std::endl;
  }
  :.
__76d2d07c70dbfc1491ed3e38f7e93c8309467b2c

meta::data('default-action', <<'__0b27c4057f19ced02b9dd5049e78f02a912922f0');
shell
__0b27c4057f19ced02b9dd5049e78f02a912922f0

meta::data('document', <<'__1a076e24950885d86aa19a7091238f14f2866b80');
= Literate Project
a Spencer Tipping
begin

- Introduction
  The \TeX{} document generator is a simple utility for encapsulating the
  generation and compilation of \TeX{} documents. Combined with literate
  Java and C++ processing, it provides a way to simultaneously write good
  documentation and simplify the build process for your program.

  It simplifies:

  e[
    + Writing \TeX{} documents quickly
    + Writing literate code
  ]e

  - Usage
    The easiest way to use the system is to clone a new project, like this:

    ::
    $ literate-project clone my-project
    :.

    Then you can edit your new project by entering its shell and issuing the
    ``e'' command:

    ::
    $ my-document shell
    my-document$ e
    :.

  %section(java_section::java-introduction)
  %section(cpp_section::cpp-introduction)
__1a076e24950885d86aa19a7091238f14f2866b80

meta::data('header', <<'__302eb61a42d4c76c8d16aa60dce481481bfdb0e8');
\documentclass{article}

%section(section::header-packages)
%section(section::header-listings)
%section(section::header-refs)

%section(section::header-cpp)
%section(section::header-java)
%section(section::header-asm)
%section(section::header-resource)

%section(section::header-proof)
__302eb61a42d4c76c8d16aa60dce481481bfdb0e8

meta::data('meta-associations', <<'__0056e44a28ba9f400494108a0efff872dd29df28');
^function:: .pl
^library:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^data::document$ .cltex
^vim_highlighter:: .vim
^java_section:: .javatex
^cpp_section:: .cpptex
^asm_section:: .asmtex
^section:: .cltex
^unlit_converter:: .pl
^line_filter:: .pl
^code_filter:: .pl
^profile:: .pl
^data::header$ .cltex
__0056e44a28ba9f400494108a0efff872dd29df28

meta::data('name', <<'__89192a5453e924c8dad5b4bedab7cdb4f89b2bd0');
literate-project
__89192a5453e924c8dad5b4bedab7cdb4f89b2bd0

meta::data('output-dir', <<'__0b27c4057f19ced02b9dd5049e78f02a912922f0');
/tmp
__0b27c4057f19ced02b9dd5049e78f02a912922f0

meta::data('pdf-output-file', <<'__1220935b0ab54e02e8006c30c5b042c8210d7ec0');
/tmp/literate-project.gcL4xXz8M52mcTkIxG4tEAezgsttH-GvdVZkYdil844/document.pdf
__1220935b0ab54e02e8006c30c5b042c8210d7ec0

meta::data('pdf-reader', <<'__0b27c4057f19ced02b9dd5049e78f02a912922f0');
evince
__0b27c4057f19ced02b9dd5049e78f02a912922f0

meta::data('pdftex', <<'__01657b64298df02eae3f3f00ad4c0fb4ed0aeb40');
pdflatex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__01657b64298df02eae3f3f00ad4c0fb4ed0aeb40

meta::data('source-directory', <<'__4a45e9044eba547b6171bca8b5abef546bd74300');
/tmp/src
__4a45e9044eba547b6171bca8b5abef546bd74300

meta::data('table-of-contents', <<'__0b27c4057f19ced02b9dd5049e78f02a912922f0');
1
__0b27c4057f19ced02b9dd5049e78f02a912922f0

meta::data('tex', <<'__62453824969eb0a703b751844757f280258a3090');
latex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__62453824969eb0a703b751844757f280258a3090

meta::function('add-to', <<'__034dc988a3b9d65c347896e44c26b1504973dfe0');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__034dc988a3b9d65c347896e44c26b1504973dfe0

meta::function('cat', <<'__d8c73dd00d45e202e5a954205a4deb7c8ce20198');
my ($name) = @_;
$data{$name};
__d8c73dd00d45e202e5a954205a4deb7c8ce20198

meta::function('clean', <<'__0ec80b6a66a9abd8e293bcb8b693d2a0aa6d28f0');
my $output_directory = &{'pdf-output-file'}();
$output_directory =~ s+/.*++g;
unlink <$output_directory/*>;
rmdir $output_directory;
__0ec80b6a66a9abd8e293bcb8b693d2a0aa6d28f0

meta::function('clone', <<'__8bcdbca03e26a1b8e4c4cde0a91e8d9495d322d8');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__8bcdbca03e26a1b8e4c4cde0a91e8d9495d322d8

meta::function('compile', <<'__4abd766ef970c578b11a748074749da8c306d550');
my $tex_command         = tex();
my $pdftex_command      = pdftex();
my $filename            = 'document';

my $contents            = &{'compile-to-tex'}();
my $output_directory    = &{'output-dir'}();
chomp $output_directory;

my $temporary_directory = state_based_filename();
$temporary_directory =~ s+^.*/++;
$temporary_directory = "$output_directory/$temporary_directory";

$tex_command    =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$tex_command    =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

$pdftex_command =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$pdftex_command =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

mkdir $temporary_directory;
file::write("$temporary_directory/$filename.tex", $contents);

my $result = &{'table-of-contents'}() ? system($tex_command) || system($tex_command) || system($pdftex_command) : system($pdftex_command);

associate('data::pdf-output-file', "$temporary_directory/$filename.pdf", execute => 1);
$result;
__4abd766ef970c578b11a748074749da8c306d550

meta::function('compile-to-tex', <<'__1e9e9b40e51eb2d8219a76acb7915644cae96208');
my ($document) = document();
$document = &$_($document) for (grep /^unlit_converter::/, sort keys %data);
$document;
__1e9e9b40e51eb2d8219a76acb7915644cae96208

meta::function('cp', <<'__81043c18707c4138726c4b40557d0b30419f3ca8');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__81043c18707c4138726c4b40557d0b30419f3ca8

meta::function('create', <<'__bc27b918ade7d018076387cc00b3ecb0d3100b28');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__bc27b918ade7d018076387cc00b3ecb0d3100b28

meta::function('e', <<'__e77e4f88d416e6e88b65a9c43b6ea6b8c708e220');
edit('data::document', extension => '.tex');
reload();
__e77e4f88d416e6e88b65a9c43b6ea6b8c708e220

meta::function('edit', <<'__62f42ff68e2dce085c035aeac6dcd01889b5a7e8');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
delete $data{$name} if length($data{$name}) == 0;

save();
__62f42ff68e2dce085c035aeac6dcd01889b5a7e8

meta::function('exists', <<'__ed7cd3a08670be10217f6f6c2f291ee4ee8ec180');
my $name = shift;
grep {$_ eq $name} keys %data;
__ed7cd3a08670be10217f6f6c2f291ee4ee8ec180

meta::function('export', <<'__a0a5e6f8ff03fbd8884952a071c36c74dca19d30');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map {cat($_)} @attributes;
  file::write ($name, $file);
} else {
  messages::error ("Not enough arguments");
}
__a0a5e6f8ff03fbd8884952a071c36c74dca19d30

meta::function('files', <<'__ff79fe9021cfbc0807007384d601f644fd2416c0');
# Quickly generate files
terminal::message('status', 'Generating files from main document...');
&{'compile-to-tex'}();
terminal::message('status', 'Done.');
__ff79fe9021cfbc0807007384d601f644fd2416c0

meta::function('grab', <<'__2a2ff1f06bfd5860ba1467224d377064a4d3d36c');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__2a2ff1f06bfd5860ba1467224d377064a4d3d36c

meta::function('import', <<'__35186ce8e0008a3c475e7ee8ce22eba8eb0147b8');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__35186ce8e0008a3c475e7ee8ce22eba8eb0147b8

meta::function('import-bundle', <<'__8f4056900159fc187bf4fff4ff38e4c271bebb88');
eval join '', <STDIN>;
messages::error($@) if $@;

__8f4056900159fc187bf4fff4ff38e4c271bebb88

meta::function('lock', <<'__0a6ef8184203a9e00d7b3a68b3ea4cdce5206718');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__0a6ef8184203a9e00d7b3a68b3ea4cdce5206718

meta::function('ls', <<'__ae90207f7fc22688f52c3c20833a1ab684f99484');
my $criteria = join '|', @_;
my @lines = grep /$criteria/, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__ae90207f7fc22688f52c3c20833a1ab684f99484

meta::function('ls-a', <<'__525bc068df4bf0228d806548819ddee3a00f51a8');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__525bc068df4bf0228d806548819ddee3a00f51a8

meta::function('make', <<'__8ec94f99998dc5087f2ffdcc19ef08a65af8ffcc');
compile() || view();
clean();
__8ec94f99998dc5087f2ffdcc19ef08a65af8ffcc

meta::function('mv', <<'__ee90b658b07f7d1e8ef24770269056306133392c');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
associate($to, retrieve($from));
rm($from);
__ee90b658b07f7d1e8ef24770269056306133392c

meta::function('new', <<'__9779a1b0838da12458e7d18cec2bf1e8ef592428');
clone(@_);
__9779a1b0838da12458e7d18cec2bf1e8ef592428

meta::function('perl', <<'__dadbc1389e6bececc479a96836ef4a984db32d08');
my $result = eval($_[0]);
$@ ? $@ : $result;
__dadbc1389e6bececc479a96836ef4a984db32d08

meta::function('pop-state', <<'__9f332e60ed3a06256755d1c40762d640418eadec');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__9f332e60ed3a06256755d1c40762d640418eadec

meta::function('pull', <<'__2fe532e0e1a07cd40522c2e0136ff568097a04b0');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__2fe532e0e1a07cd40522c2e0136ff568097a04b0

meta::function('push-state', <<'__828f0ca8ca67a8f0a6fa7c468465f2cc7cce2e42');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__828f0ca8ca67a8f0a6fa7c468465f2cc7cce2e42

meta::function('reload', <<'__00b9039c103cfa406a2e0070092823e4ca1ca968');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__00b9039c103cfa406a2e0070092823e4ca1ca968

meta::function('render', <<'__cf13120859d0beb2a904ad26f2b9922cda7b3320');
use File::Copy 'cp';

terminal::message('status', 'Building PDF...');
compile();
terminal::message('status', 'Copying PDF to source directory');
cp(&{'pdf-output-file'}(), &{'source-directory'} . '/' . name() . '.pdf');
__cf13120859d0beb2a904ad26f2b9922cda7b3320

meta::function('rm', <<'__f5e76ae8a069901026783b40c18272a2c0f52e99');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__f5e76ae8a069901026783b40c18272a2c0f52e99

meta::function('save', <<'__e6a1aaf4b6556238c3174820552301208d2906c4');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__e6a1aaf4b6556238c3174820552301208d2906c4

meta::function('serialize', <<'__a523cd97b5fd28a8c0f61530cc783ee850c05a57');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && m/$criteria/, sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;

__a523cd97b5fd28a8c0f61530cc783ee850c05a57

meta::function('shell', <<'__f9ddecd04b3f3248fa31f9feb4cf703478976ce0');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'name'}() . '$ ';
}
__f9ddecd04b3f3248fa31f9feb4cf703478976ce0

meta::function('size', <<'__06791c8c37f59a0070308a0811c0b59897bb43af');
length(serialize());
__06791c8c37f59a0070308a0811c0b59897bb43af

meta::function('snapshot', <<'__f3d6e5d8627a085a994ac4b06b289c746aee70d0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__f3d6e5d8627a085a994ac4b06b289c746aee70d0

meta::function('state', <<'__3d3222a03b60b6c8a9d289ce22de2e9abafc6778');
sha256_base64 serialize();
__3d3222a03b60b6c8a9d289ce22de2e9abafc6778

meta::function('unlock', <<'__0a6ef8184203a9e00d7b3a689f6ae4ac23322820');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__0a6ef8184203a9e00d7b3a689f6ae4ac23322820

meta::function('update-from', <<'__39064450cae7a1586aab086175296640608863b8');
# Upgrade all attributes that aren't customized. In this case, we want everything except for configuration::, code::, and attribute::.
return "That is a really bad idea." if $0 =~ /\.\/(.*)/ && $_[0] eq $1 || $_[0] eq $0;

my @attributes = map {s/\s+.*//; $_} split(/\n/, qx|$_[0] ls-a|);

terminal::message('info', 'Replicating state...');
&{'push-state'}();
terminal::message('info', 'Updating meta attributes...');
for my $attribute (grep length && /^meta::/, @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();
  print '.';
}

print "\n";
terminal::message('info', 'Updating non-meta attributes...');
for my $attribute (grep length && ! (/^configuration::/ || /^code::/ || /^attribute::/ || /^function::pop-state$/ ||
                                     /^list::/ || /^issue::/ || /^data::/ || /^meta::datatypes/), @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();     # Necessary to activate new datatypes.
  print '.';
}

print "\n";
terminal::message('info', 'Reloading new configuration');
reload();
terminal::message('info', "Imported from $_[0]. Run pop-state to undo this change.");
__39064450cae7a1586aab086175296640608863b8

meta::function('usage', <<'__687ace96b07cb784693313e8538b89e0d7556edc');
<<"EOD" . ls ();
Usage: $0 [options] action [arguments]
Defined actions (and the attribute that defines them):
EOD
__687ace96b07cb784693313e8538b89e0d7556edc

meta::function('view', <<'__ba5ed66c2bd3c7acda3f08c8ce7721b0492893e8');
my $pdf_reader      = &{'pdf-reader'}();
my $pdf_output_file = &{'pdf-output-file'}();
chomp $pdf_reader;
system("$pdf_reader '$pdf_output_file'");
__ba5ed66c2bd3c7acda3f08c8ce7721b0492893e8

meta::function('vim', <<'__921dce569d3825e09152d45631b04660a883921e');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__921dce569d3825e09152d45631b04660a883921e

meta::internal_function('associate', <<'__e2f6638c2004f25809e5ed487afdfe80777e90b0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__e2f6638c2004f25809e5ed487afdfe80777e90b0

meta::internal_function('basename', <<'__9264831c13f20c4038bc51c04523e60784ac9505');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__9264831c13f20c4038bc51c04523e60784ac9505

meta::internal_function('complete', <<'__d3a05408732df2b869dc1f74937cdd908c409b64');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__d3a05408732df2b869dc1f74937cdd908c409b64

meta::internal_function('execute', <<'__212c3f0165477514627b0a08e9a5136c11d06160');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__212c3f0165477514627b0a08e9a5136c11d06160

meta::internal_function('fast_hash', <<'__3e9de0b4ebf1ead4442da0e0379e5d08a0330e10');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = map substr($data, $piece_size * $_, $piece_size), 0 .. 7;
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_] . $hashes[-1]) for 0 .. 7;
push @hashes, fnv_hash(substr($data, $piece_size * 8) . length($data));

$hashes[$_] ^= $hashes[$_ + 4] for 0 .. 3;

sprintf '%08x' x 5, @hashes[0 .. 3], $hashes[8];

__3e9de0b4ebf1ead4442da0e0379e5d08a0330e10

meta::internal_function('file::read', <<'__a9dcc370c25299a439f53f48a292bd54d5872450');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__a9dcc370c25299a439f53f48a292bd54d5872450

meta::internal_function('file::write', <<'__e27cdf44fa10cad03138bdf8bf4eadd8293085a8');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__e27cdf44fa10cad03138bdf8bf4eadd8293085a8

meta::internal_function('fnv_hash', <<'__dfcdff5099c85850c662d2509db43a24c1b945d0');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

(($hash ^= $_) *= $fnv_prime) %= $modulus for unpack('ccccL*', $data . substr($data, -4));
$hash;

__dfcdff5099c85850c662d2509db43a24c1b945d0

meta::internal_function('invoke_editor_on', <<'__337fb3e07fa468dc526a8e686947dad0b8605ec0');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__337fb3e07fa468dc526a8e686947dad0b8605ec0

meta::internal_function('messages::error', <<'__f9ac51189db7434081aa077af60d8f968f835300');
my ($message) = @_;
die "$message\n";
__f9ac51189db7434081aa077af60d8f968f835300

meta::internal_function('messages::warning', <<'__f9ac51189db7434019b5c1861d35837651d87d20');
my ($message) = @_;
print "$message\n";
__f9ac51189db7434019b5c1861d35837651d87d20

meta::internal_function('namespace', <<'__9264831c13f20c4046ffb300440fdfd3020f3040');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__9264831c13f20c4046ffb300440fdfd3020f3040

meta::internal_function('retrieve', <<'__19cb3368500ca29133c9af4b0aeca2d006e92cdc');
@data{@_};
__19cb3368500ca29133c9af4b0aeca2d006e92cdc

meta::internal_function('serialize::single', <<'__042724db6db0b5742514e64fb4be2e6c94f73dd2');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__042724db6db0b5742514e64fb4be2e6c94f73dd2

meta::internal_function('serialize_single', <<'__4425fdc9fbf79c606714e7a48b56fc70244f9aa0');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = '__' . fast_hash($contents);
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";

__4425fdc9fbf79c606714e7a48b56fc70244f9aa0

meta::internal_function('state_based_filename', <<'__b311f9c8cb487680ba86665ce3fd4f0e73b5d404');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__b311f9c8cb487680ba86665ce3fd4f0e73b5d404

meta::java_section('java-introduction', <<'__2069ecd847abc7f05d7381c0834756d8e14003a0');
- Introduction to Java Literate Coding
  Literate coding allows you to write \TeX{} primarily, but insert Java code snippets where appropriate.\footnote{Take a look at {\tt java\_section::java-introduction} to see the how to set
  the language and options for code sections.} For example:

  :: java class=test
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is a test class");
    }
  }
  :.

  :: java class=test package=com.spencertipping
  package com.spencertipping;
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is in package com.spencertipping.");
    }
  }
  :.

  Compiling the system is also simple:

  ::
  $ ./my-project compile
  :.

  This generates all of the Java source files in a directory, usually {\tt /tmp/src/}. The output directory can be changed like this:

  ::
  $ ./my-project source-directory = src/
  :.
__2069ecd847abc7f05d7381c0834756d8e14003a0

meta::library('terminal', <<'__7f27e8189c10f7b06f17f9a4bb0c25c06af099b0');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__7f27e8189c10f7b06f17f9a4bb0c25c06af099b0

meta::line_filter('convert_header_info', <<'__d9d88f188b3fa5e03f276c36441d66a84a0c90c0');
my ($line) = @_;

$line =~ s/^= (.*)$/\\title{$1}/;
$line =~ s/^a (.*)$/\\author{$1}/;
$line =~ s/^d (.*)$/\\date{$1}/;

my $document_header = '\begin{document}\maketitle';
$document_header .= '\tableofcontents' if &{'table-of-contents'}();

$line =~ s/^begin$/$document_header/;

$line;
__d9d88f188b3fa5e03f276c36441d66a84a0c90c0

meta::line_filter('convert_itemized_environments', <<'__d5e03bfd5dd50a78d28025747eea221013ce2820');
my ($line) = @_;

$line =~ s/^\s*\+ /\\item /;
$line =~ s/^\s*\+\[([^\]]*)\] /\\item[\1] /;

$line =~ s/^\s*e\[$/\\begin{enumerate}/;
$line =~ s/^\s*i\[$/\\begin{itemize}/;
$line =~ s/^\s*d\[$/\\begin{description}/;

$line =~ s/^\s*a\[$/\\begin{align*}/;

$line =~ s/^\s*\]e$/\\end{enumerate}/;
$line =~ s/^\s*\]i$/\\end{itemize}/;
$line =~ s/^\s*\]d$/\\end{description}/;

$line =~ s/^\s*\]a$/\\end{align*}/;

$line;
__d5e03bfd5dd50a78d28025747eea221013ce2820

meta::line_filter('convert_sections', <<'__b97d64492ab40988db2a4f15ec13bf88047fc8f2');
my ($line) = @_;

my %indentation_levels = (
  0 => '\section',
  2 => '\subsection',
  4 => '\subsubsection',
  6 => '\paragraph',
  8 => '\subparagraph');

if ($line =~ /^(\s*)- (.*)$/) {
  my $section = $indentation_levels{length($1)} || die "Invalid indentation level:\n$_";
  my $section_name = $2;
  my $label_name   = lc $section_name;

  $label_name =~ s/[^A-Za-z0-9.]/-/g;

  "${section} {$section_name} \\label{sec:$label_name}";
} else {
  $line;
}
__b97d64492ab40988db2a4f15ec13bf88047fc8f2

meta::section('header-asm', <<'__00ce4e606f080cf8303278801c8a90fe5f04a5cc');
\lstnewenvironment{asmcode} {}{}
__00ce4e606f080cf8303278801c8a90fe5f04a5cc

meta::section('header-cpp', <<'__c7ff94d05ea836102b4b8d880da6e600405d59b4');
\lstnewenvironment{cppcode} {\lstset{language=c++}} {}
__c7ff94d05ea836102b4b8d880da6e600405d59b4

meta::section('header-java', <<'__43cec188a4502d90dd2b80f0ce9a7fb0e30a46f0');
\lstnewenvironment{javacode}{\lstset{language=java}}{}
__43cec188a4502d90dd2b80f0ce9a7fb0e30a46f0

meta::section('header-listings', <<'__05326ff0a31d59a85724aa6c94891594e11879c2');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__05326ff0a31d59a85724aa6c94891594e11879c2

meta::section('header-packages', <<'__7e2d34f4201b662f20aba628f2f227bcc600cbb8');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__7e2d34f4201b662f20aba628f2f227bcc600cbb8

meta::section('header-proof', <<'__9beb226e1a2bd9627f7a40d8b6b3c664d3c1e920');
\newenvironmemnt{proof}{\par\noindent\textbf{Proof.}}{\hfill$\square$}
__9beb226e1a2bd9627f7a40d8b6b3c664d3c1e920

meta::section('header-refs', <<'__d1b9293899080168718381946f530fb044b739e0');
\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}
__d1b9293899080168718381946f530fb044b739e0

meta::section('header-resource', <<'__00ce4e601cac6d79d6f04368f0368bd0d64c93ec');
\lstnewenvironment{resource}{}{}
__00ce4e601cac6d79d6f04368f0368bd0d64c93ec

meta::unlit_converter('create_sections', <<'__da88bdd8f5fa4c9c097d0d967f14e9008b8a1488');
my ($document) = @_;
1 while $document =~ s/^\s*%section\(([^)]+)\)\s*$/\n$data{$1}\n/omg;
$document;
__da88bdd8f5fa4c9c097d0d967f14e9008b8a1488

meta::unlit_converter('main', <<'__88c16bbce80366a886e89d92c63fde38e7e80e02');
my ($document) = @_;

my $sections_already_encountered = 0;
my $inside_code_block            = 0;
my $code_block_indentation       = 0;
my $code_section_name            = '';
my $result                       = '';

for (split /\n/, $document) {
  # Handle code blocks.
  if (/^(\s*):\.$/) {
    $inside_code_block = $code_block_indentation = 0;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, end => 1);
    }
  }

  if ($inside_code_block) {
    my $spaces_to_delete = ' ' x $code_block_indentation;
    s/^$spaces_to_delete//;
    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation);
    }
  } else {
    for my $filter_name (grep /^line_filter::/, sort keys %data) {
      $_ = &$filter_name($_);
    }
  }

  if (/^(\s*)::(\s.*)?$/) {
    $inside_code_block      = 1;
    $code_block_indentation = length($1);
    $code_section_name      = $2;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, begin => 1);
    }
  }

  $result .= "$_\n";
}

$result;
__88c16bbce80366a886e89d92c63fde38e7e80e02

meta::unlit_converter('zz_append_footer', <<'__23190ba449f1fc407d7e4fe80b1f339852986c63');
my ($document) = @_;
"$document\n\\end{document}";
__23190ba449f1fc407d7e4fe80b1f339852986c63

meta::unlit_converter('zz_prepend_header', <<'__46b4c02411a339ba6dfc921c38df2e3805012f18');
my ($document) = @_;
header() . "\n$document";
__46b4c02411a339ba6dfc921c38df2e3805012f18

meta::vim_highlighter('asmtex', <<'__bc2d215061bbb390248d64703da83f7b00ba6960');
" TeX with Assembly
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with Assembly in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region asmtexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<asm\>.*$/ contains=asmtexSection
syn match  asmtexSection /^\s*- .*$/ contained

runtime! syntax/asm.vim

hi link asmtexSection Special
hi link asmtexComment Comment

let b:current_syntax = "asmtex"
__bc2d215061bbb390248d64703da83f7b00ba6960

meta::vim_highlighter('cltex', <<'__07bc9ff4440c65a8024af2e24717a356df74fdd0');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match  cltTitle   /^= .*$/
syn match  cltAuthor  /^a .*$/
syn match  cltDate    /^d .*$/
syn match  cltBegin   /^begin$/
syn match  cltSection /^\s*- .*$/
syn region cltVerbatim start=/^\s*::$/ end=/^\s*:\.$/

syn match  cltEnumeratedThing /^\s*[eid]\[/
syn match  cltEnumeratedThing /^\s*\][eid]/
syn match  cltItem            /^\s*+\s/
syn match  cltQuantifiedItem  /^\s*+\[[^\]]*\]\s/

runtime! syntax/tex.vim

syn match  cltInclude /^\s*%section([^)]\+)$/

hi link cltBegin    Keyword
hi link cltTitle    Identifier
hi link cltAuthor   Identifier
hi link cltDate     Identifier

hi link cltEnumeratedThing Special
hi link cltItem            Special
hi link cltQuantifiedItem  Special
hi link cltInclude         Special

hi link cltSection  Type

hi link cltVerbatim String

let b:current_syntax = "cltex"
__07bc9ff4440c65a8024af2e24717a356df74fdd0

meta::vim_highlighter('cpptex', <<'__ed79ea609df93274498774d873208bb8ad2a066c');
" TeX with C++
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with C++ in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region cpptexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<cpp\>.*$/ contains=cpptexSection
syn match  cpptexSection /^\s*- .*$/ contained

runtime! syntax/cpp.vim

syn match  cpptexInclude /#include\s\+\(\w\|[_()]\)\+/

hi link cpptexSection Special
hi link cpptexComment Comment
hi link cpptexInclude PreProc

let b:current_syntax = "cpptex"
__ed79ea609df93274498774d873208bb8ad2a066c

meta::vim_highlighter('javatex', <<'__3e1e0b38b5b65eac67dc2e48e09dc4bf7aeb0c88');
" TeX with Java
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with Java in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region javatexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<java\>.*$/ contains=javatexSection
syn match  javatexSection /^\s*- .*$/           contained

runtime! syntax/java.vim

hi link javatexSection Special
hi link javatexComment Comment

let b:current_syntax = "javatex"
__3e1e0b38b5b65eac67dc2e48e09dc4bf7aeb0c88

meta::internal('runtime', <<'__ca426248a86626f523247d840dfac5e4b0cd66e0');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__ca426248a86626f523247d840dfac5e4b0cd66e0

__END__