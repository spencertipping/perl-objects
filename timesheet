#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

meta::meta('configure', <<'__25976e07665878d3fae18f050160343f');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__25976e07665878d3fae18f050160343f

meta::meta('externalize', <<'__9141b4e8752515391385516ae94b23b5');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9141b4e8752515391385516ae94b23b5

meta::meta('functor::editable', <<'__23cd7b7dc81d5cebd632c7543a30af99');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;
  
  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return preprocess(retrieve($attribute))                                              if $options{preprocess};
      return retrieve($attribute);
    };
  };
}
__23cd7b7dc81d5cebd632c7543a30af99

meta::meta('internal::runtime', <<'__0172b18c9b9311477d2f6b8c16bb44c2');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__0172b18c9b9311477d2f6b8c16bb44c2

meta::meta('type::bootstrap', <<'__297d03fb32df03b46ea418469fc4e49e');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__297d03fb32df03b46ea418469fc4e49e

meta::meta('type::data', "meta::functor::editable 'data', extension => '', inherit => 0, default => 'cat';");
meta::meta('type::function', <<'__af5dd5ecc27fe503f68b041791bee6ca');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__af5dd5ecc27fe503f68b041791bee6ca

meta::meta('type::internal_function', <<'__cb453a81adfa24b238c9b69e0b372ec8');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  warn $@ if $@;
};
__cb453a81adfa24b238c9b69e0b372ec8

meta::meta('type::library', <<'__455137a61f5af29340946d69bc68d663');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;

  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__455137a61f5af29340946d69bc68d663

meta::meta('type::message_color', <<'__794bf137c425293738f07636bcfb5c55');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__794bf137c425293738f07636bcfb5c55

meta::meta('type::meta', <<'__640f25635ce2365b0648962918cf9932');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__640f25635ce2365b0648962918cf9932

meta::meta('type::note', "meta::functor::editable 'note', extension => '', inherit => 0, default => 'edit';");
meta::meta('type::state', <<'__c1f29670be26f1df6100ffe4334e1202');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__c1f29670be26f1df6100ffe4334e1202

meta::meta('type::template', <<'__31e3d1be8d2d32b285ebb90645d5f37a');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__31e3d1be8d2d32b285ebb90645d5f37a

meta::meta('type::vim_highlighter', "meta::functor::editable 'vim_highlighter', extension => '.vim', inherit => 1, default => 'edit';");
meta::meta('type::watch', "meta::functor::editable 'watch', prefix => 'watch::', inherit => 1, extension => '.pl', default => 'cat';");
meta::bootstrap('initialization', <<'__d2491ab72f79f70883bd583202562e94');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

__d2491ab72f79f70883bd583202562e94

meta::data('default-action', 'edit-times');
meta::data('license', <<'__3c6177256de0fddb721f534c3ad8c0ee');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__3c6177256de0fddb721f534c3ad8c0ee

meta::data('name', 'timesheet');
meta::data('quiet', '1');
meta::data('times', <<'__129245221c65e95871fd1f421f2cc77e');
# Times go here. They are in the following format:
# <date>  <start>  <end>
# where each field is separated from the others by at least two spaces.
# Note that dates can have spaces, but not two spaces in a row. They
# aren't parsed in any way, so that field could be used for nearly
# anything.

# Start and end times should be in 24-hour format, for example 13:00.
# If you work after midnight, don't wrap the time around zero -- report
# it as 24:00 or 25:00. This timesheet is uninsightful about time
# subtraction and will subtract hours from the total if the end time
# seems to be less than the start time.

# For example:
December 10, 2010       09:00   17:00
December 11, 2010       23:00   24:30   # 11PM to 12:30AM
__129245221c65e95871fd1f421f2cc77e

meta::data('watching', '1');
meta::function('cat', <<'__c8e76a0cf10e2061e9cf9e1643922c3e');
my ($name) = @_;
$data{$name};
__c8e76a0cf10e2061e9cf9e1643922c3e

meta::function('clone', <<'__fec8cf43b197da97cfd5e49d75891d57');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__fec8cf43b197da97cfd5e49d75891d57

meta::function('cp', <<'__ffba0c53d9c2d03d8d6e5f9692f496ae');
my ($from, $to) = @_;
my $exists = exists $data{$from};
associate($to, retrieve($from)) if $exists;
messages::error("No such attribute $from") unless $exists;
retrieve($from);
__ffba0c53d9c2d03d8d6e5f9692f496ae

meta::function('create', <<'__3349f4fb38464e1869a43e25af881986');
my ($name, $value) = @_;

messages::error("Attribute $name already exists.") if grep $_ eq $name, keys %data;
if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__3349f4fb38464e1869a43e25af881986

meta::function('csv', <<'__465eb739f70fe3eb34f78bd26f658364');
my $times = retrieve('data::times');

my $minute_total = 0;
my $current_line = 0;
my @new_lines;

for my $line (split /\n/, $times) {
  ++$current_line;
  next if $line =~ /^\s*#/o || ! length $line;
  my @line_bits = split /\s{2,}/, $line;
  my $new_line  = '"' . (join '","', @line_bits) . '"';

  my @start_time = split /:/, $line_bits[1];
  my @end_time   = split /:/, $line_bits[2];

  my $current_duration = ($end_time[0] - $start_time[0]) * 60 + $end_time[1] - $start_time[1];
  $minute_total += $current_duration;

  terminal::message('warning', "Negative time on line $current_line") if $current_duration < 0;

  push @new_lines, $new_line;
}

my $hour_total = 0;
++$hour_total, $minute_total -= 60 while $minute_total >= 60;
my $formatted_minutes = sprintf '%02d', $minute_total;
(join "\n", @new_lines) . "\n\"Total\",\"\",\"\",\"$hour_total:$formatted_minutes\"";
__465eb739f70fe3eb34f78bd26f658364

meta::function('current-state', <<'__0d932bd14547669ffbc86fde3ae9d050');
my @valid_keys   = grep ! /^internal::runtime$/ && ! /^state::/, sort keys %data;
my @ordered_keys = (grep(/^meta::/, @valid_keys), grep(! /^meta::/, @valid_keys));
join "\n", map serialize_single($_), @ordered_keys;
__0d932bd14547669ffbc86fde3ae9d050

meta::function('edit', <<'__fd66065bde6c1783dd3345474f93cc9e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

messages::error("Attribute $name does not exist.") unless grep $_ eq $name, keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, attribute => $name, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__fd66065bde6c1783dd3345474f93cc9e

meta::function('edit-times', "edit('data::times');");
meta::function('export', <<'__6d9cbe5959a6431316eb690cd8dbc79a');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  messages::error("Not enough arguments");
}
__6d9cbe5959a6431316eb690cd8dbc79a

meta::function('hash', <<'__7c4145cf6e97dfb9ab04a613866751d3');
my ($data) = @_;
fast_hash($data);
__7c4145cf6e97dfb9ab04a613866751d3

meta::function('import', <<'__84d29edfe7ad2119465fdcf7d037ed1c');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__84d29edfe7ad2119465fdcf7d037ed1c

meta::function('import-bundle', <<'__f8e525756a0de302fa1d1d209d167e3b');
eval join '', <STDIN>;
messages::error($@) if $@;
__f8e525756a0de302fa1d1d209d167e3b

meta::function('load-state', <<'__878f141333993ead4d272027ad301eee');
my ($state_name) = @_;
my $state = retrieve("state::$state_name");

terminal::message('state', 'Saving current state into _...');
&{'save-state'}('_');

terminal::message('state', 'Removing attributes from %data and unexternalizing functions...');
delete $data{$_} for grep ! /^state::/ && ! /^internal::runtime$/, keys %data;
%externalized_functions = ();

terminal::message('state', "Restoring state $state_name...");
eval($state);
terminal::message('error', $@) if $@;
reload();
verify();
__878f141333993ead4d272027ad301eee

meta::function('lock', <<'__d94992bf224487f5bfd439eb822db309');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__d94992bf224487f5bfd439eb822db309

meta::function('ls', <<'__d900070fd20c5c0ae08280b0f354666f');
my $criteria = join '|', @_;
my @lines = grep /$criteria/ && defined $data{$externalized_functions{$_}}, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__d900070fd20c5c0ae08280b0f354666f

meta::function('ls-a', <<'__f2fdfdd82d77a876b485332dbd1446fa');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . sprintf('%6d  ', length(serialize_single($_))) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__f2fdfdd82d77a876b485332dbd1446fa

meta::function('mv', <<'__994133604ac769fe978c4c127fd5011c');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

return messages::error("'$from' does not exist.") unless grep $from, keys %data;
return messages::error("The namepsace '$destination_namespace' does not exist") unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__994133604ac769fe978c4c127fd5011c

meta::function('note', <<'__bcbfeac6dd2112f47296265444570a6e');
# Creates a note with a given name, useful for jotting things down.
create("note::$_[0]");
__bcbfeac6dd2112f47296265444570a6e

meta::function('perl', <<'__d8818fd77e9e7ce68811e0947dfcc206');
my $result = eval($_[0]);
$@ ? $@ : $result;
__d8818fd77e9e7ce68811e0947dfcc206

meta::function('preprocess', <<'__5490aa94527756b14ac589937f717611');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $did_something      = 1;
my $limit              = $options{expansion_limit} || 10;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  $string;
}

while ($did_something and $expansions++ < $limit) {
  $did_something = 0;

  if ((my @pieces = split  /^(\h* -\h \S+ \h+ \V*? <<\h*(\w+)$ \n .*?  ^\h*-\h\2)$/xms, $string) > 1) {
    $pieces[1 + $_ * 3] =~ /^(\h*)-\h(\S+)\h+(\V*?)<<\h*(\w+)$ \n(.*?) ^\1 -\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + $_ * 3] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 3;

    $pieces[2 + $_ * 3] = '' for 0 .. $#pieces / 3;
    $string = join '', @pieces;
    $did_something = 1;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h+ .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h+(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
    $did_something = 1;
  }
}

$string;
__5490aa94527756b14ac589937f717611

meta::function('reload', 'execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;');
meta::function('rm', <<'__e3c840f6c0b12ec504df30595b5bb94d');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__e3c840f6c0b12ec504df30595b5bb94d

meta::function('save', <<'__026f80315df6aef78ccb734c6ab250f3');
if (! verify()) {
  messages::error("$0 has not been updated.");
} else {
  my $serialized_data = serialize();
  eval {file::write($0, $serialized_data)};
  messages::error($@) if $@;
  terminal::message('info', "$0 saved successfully.");
}
__026f80315df6aef78ccb734c6ab250f3

meta::function('save-state', <<'__5c5b586331e25951140ced6442d9fe2b');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
associate("state::$state_name", &{'current-state'}(), execute => 1);
__5c5b586331e25951140ced6442d9fe2b

meta::function('serialize', <<'__d7b3affaece3a36d5cfc051b88a5b76e');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && (! $criteria || m/$criteria/), sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;
__d7b3affaece3a36d5cfc051b88a5b76e

meta::function('serialize_single', <<'__91663f820a05ff4029a200fbfd7285bc');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $meta_function_name = 'meta::' . namespace($name);
my $invocation_name    = basename($name);

return "$meta_function_name('$invocation_name', '$contents');"   if $contents =~ /^[^\n']*$/;
return "$meta_function_name('$invocation_name', \"$contents\");" if $contents =~ /^[^\n"\\\$@%&]*$/;

my $delimiter = '__' . fast_hash($contents);
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__91663f820a05ff4029a200fbfd7285bc

meta::function('shell', <<'__364c77a8a88ef137c00350b27d2d2a5e');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $output = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';
  associate('data::watching', 0, execute => 1), next if $function_name eq 'disable-watch';
  associate('data::watching', 1, execute => 1), next if $function_name eq 'enable-watch';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      chomp(my $result = eval {&$function_name(@args)});
      messages::warning($@) if $@;
      print $output $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  if (watching()) {
    for my $watch (map retrieve($_), grep /^watch::/, sort keys %data) {
      terminal::message('watch',   "$watch => " . eval($watch));
      terminal::message('warning', "Error evaluating watched expression $watch: $@") if $@;
    }
  }

  $prompt = name() . '$ ';
}
__364c77a8a88ef137c00350b27d2d2a5e

meta::function('size', 'length(serialize());');
meta::function('snapshot', <<'__ccb6335f4837338be1d73ccc5f81973d');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('state', "Created snapshot at $finalname.");
__ccb6335f4837338be1d73ccc5f81973d

meta::function('state', <<'__e17520e3a5d81d788ae995fd8ac47cb9');
my @keys = sort keys %data;
my $hash = fast_hash(scalar @keys);
$hash = fast_hash($hash . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__e17520e3a5d81d788ae995fd8ac47cb9

meta::function('unlock', <<'__b1bdb7eb224487f5bfd439ebb997c823');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__b1bdb7eb224487f5bfd439ebb997c823

meta::function('update-from', <<'__c9570d6953ba16e3abaa217b0b202b3e');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.

my $target  = $_[0] or die 'Must specify another script to pull data from.';
my @options = grep /^-/, @_;

&{'save-state'}('before-update');

terminal::message('info', 'Updating meta attributes...');
eval qx($target serialize '^meta::');
terminal::message('warning', $@) if $@;
terminal::message('warning', 'One of the meta-attributes triggered a verification failure.') unless verify();

terminal::message('info', 'Updating non-meta attributes...');
my $combined_pattern = join '|', map "^${_}::", grep ! (/^meta$/ || /^internal$/) && $transient{inherit}{$_}, sort keys %{$transient{inherit}};
eval qx($target serialize '$combined_pattern');
terminal::message('warning', $@) if $@;
reload();

if (verify()) {
  terminal::message('info', "Successfully updated from $_[0]. Run 'load-state before-backup' to undo this change.");
} elsif (grep /^--force$/o || /^-f$/o, @options) {
  terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
  terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
  terminal::message('info',    'Run "load-state before-backup" to undo the update and return to a working state.');
} else {
  terminal::message('error', 'Verification failed after the upgrade was complete.');
  terminal::message('info',  "$0 has been reverted to its pre-upgrade state.");
  terminal::message('info',  "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
  &{'load-state'}('before-update');
}
__c9570d6953ba16e3abaa217b0b202b3e

meta::function('usage', <<'__234b1da5bb4e34d72a932ab68aad5052');
<<"EOD" . ls ();
Usage: $0 action [arguments]
Defined actions (and the attribute that defines them):
EOD
__234b1da5bb4e34d72a932ab68aad5052

meta::function('verify', <<'__e8ff828f42cdc7d759b70bb81721ddb6');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
$transient{temporary_filename} = $temporary_filename;
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
unlink $temporary_filename if $result;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;

$result;
__e8ff828f42cdc7d759b70bb81721ddb6

meta::function('vim', <<'__bd231af998c353790253bc6660be0b90');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__bd231af998c353790253bc6660be0b90

meta::internal_function('associate', <<'__9c33cd95ac3bfa9de2f9de12c866b1c7');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__9c33cd95ac3bfa9de2f9de12c866b1c7

meta::internal_function('basename', <<'__62efb9f22157835940af1d5feae98d98');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__62efb9f22157835940af1d5feae98d98

meta::internal_function('complete', <<'__f14ae2337c0653b6bb6fd02bb6493646');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__f14ae2337c0653b6bb6fd02bb6493646

meta::internal_function('debug_trace', <<'__f887289259890731458a66398b628cdc');
quiet() or terminal::message('debug', join ', ', @_);
wantarray ? @_ : $_[0];
__f887289259890731458a66398b628cdc

meta::internal_function('execute', <<'__2d5b6f18c13943d6a0de15e9c348d428');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__2d5b6f18c13943d6a0de15e9c348d428

meta::internal_function('fast_hash', <<'__ac70f469e697725cfb87629833434ab1');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__ac70f469e697725cfb87629833434ab1

meta::internal_function('file::read', <<'__186bbcef8f6f0dd8b72ba0fdeb1de040');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__186bbcef8f6f0dd8b72ba0fdeb1de040

meta::internal_function('file::write', <<'__d05a3256f22a7a49afb85e8db507ab50');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__d05a3256f22a7a49afb85e8db507ab50

meta::internal_function('fnv_hash', <<'__8d001a3a7988631bab21a41cee559758');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__8d001a3a7988631bab21a41cee559758

meta::internal_function('invoke_editor_on', <<'__d54f75530d8fe78e078c92be20c72297');
my ($data, %options) = @_;
my $editor           = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $extension        = $options{extension} || '';
my $attribute        = $options{attribute} || '';

my $filename         = temporary_name() . "-$attribute" . $extension;

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__d54f75530d8fe78e078c92be20c72297

meta::internal_function('messages::error', <<'__5af9120535afe26fa6828f477abe833c');
my ($message) = @_;
terminal::message('error', $message);
die;
__5af9120535afe26fa6828f477abe833c

meta::internal_function('messages::warning', <<'__2877a0b67326120f9d43089368e6c4f3');
my ($message) = @_;
terminal::message('warning', $message);
__2877a0b67326120f9d43089368e6c4f3

meta::internal_function('namespace', <<'__93213d60cafb9627e0736b48cd1f0760');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__93213d60cafb9627e0736b48cd1f0760

meta::internal_function('retrieve', '@data{@_};');
meta::internal_function('state_based_filename', <<'__218815c285975367ae0324bf5c3f5409');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__218815c285975367ae0324bf5c3f5409

meta::internal_function('temporary_name', <<'__0fb1402061581b69822f913631b4a9d9');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__0fb1402061581b69822f913631b4a9d9

meta::library('terminal', <<'__6ac64319df3f331f76b5213634f2af51');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color   'debug',   'blue';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__6ac64319df3f331f76b5213634f2af51

meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::message_color('watch', 'blue');
meta::template('eval', <<'__7be1d470a07a06c58e971bc7fc24c048');
my $result = eval $_[0];
terminal::message('warning', "Error during template evaluation: $@") if $@;
$result;
__7be1d470a07a06c58e971bc7fc24c048

meta::template('failing_conditional', <<'__b49f2ffe1cfefb36b1eabd7abd7b3bb6');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::message('warning', "eval of template condition failed: $@") if $@;
$should_return;
__b49f2ffe1cfefb36b1eabd7abd7b3bb6

meta::template('include', <<'__e0624844a65ae41e0217dd871fc0dbfb');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__e0624844a65ae41e0217dd871fc0dbfb

meta::internal('runtime', <<'__570c9329c63822a15749384cb355d653');
my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
messages::warning("Unknown action: '$function_name'") and $function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

END {
  save() unless $initial_state eq state();
}

__570c9329c63822a15749384cb355d653

__END__