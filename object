#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

meta::meta('configure', <<'__1a846320e20a15012045d86889c5ac10');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__1a846320e20a15012045d86889c5ac10

meta::meta('externalize', <<'__9c27671cf4a49424bb28ddb62bf44884');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9c27671cf4a49424bb28ddb62bf44884

meta::meta('functor::editable', <<'__b9143944720fabbefe4e4770c6421a88');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;
  
  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    meta::externalize $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute);
    };
  };
}
__b9143944720fabbefe4e4770c6421a88

meta::meta('internal::runtime', <<'__43c46ff6344bc04d6dbac7f43c77ad30');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__43c46ff6344bc04d6dbac7f43c77ad30

meta::meta('type::bootstrap', <<'__74115c281ce77668fcad6f14010b1478');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__74115c281ce77668fcad6f14010b1478

meta::meta('type::data', "meta::functor::editable 'data', extension => '', inherit => 0, default => 'cat';");
meta::meta('type::function', <<'__8d6854866c9e4b2e790f9d8cb0faefd8');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", eval("sub {\n$value\n}");
  warn $@ if $@;
};
__8d6854866c9e4b2e790f9d8cb0faefd8

meta::meta('type::internal_function', <<'__55005008fd5a1a7005b2b120b9e427f4');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  warn $@ if $@;
};
__55005008fd5a1a7005b2b120b9e427f4

meta::meta('type::library', <<'__1b159400ac08a2880bb5aaec79b7c3d8');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;

  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__1b159400ac08a2880bb5aaec79b7c3d8

meta::meta('type::message_color', "meta::functor::editable 'message_color', extension => '', inherit => 1, default => 'cat';");
meta::meta('type::meta', "meta::functor::editable 'meta', extension => '.pl', inherit => 1, default => 'edit';");
meta::meta('type::note', "meta::functor::editable 'note', extension => '', inherit => 0, default => 'edit';");
meta::meta('type::vim_highlighter', "meta::functor::editable 'vim_highlighter', extension => '.vim', inherit => 1, default => 'edit';");
meta::bootstrap('initialization', <<'__bb61c08f3f1cb340417ab4984db3f408');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  warn $@ if $@;
};

__bb61c08f3f1cb340417ab4984db3f408

meta::data('default-action', 'shell');
meta::data('license', <<'__f2cf09fcaa44be7888c870b09d1cfb0e');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__f2cf09fcaa44be7888c870b09d1cfb0e

meta::data('name', 'object');
meta::data('quiet', '1');
meta::function('cat', <<'__b66d44d61aab902c56d5c808464e99e0');
my ($name) = @_;
$data{$name};
__b66d44d61aab902c56d5c808464e99e0

meta::function('clone', <<'__9cf4ea7db26e6e70bc1a496af9774380');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__9cf4ea7db26e6e70bc1a496af9774380

meta::function('cp', <<'__e9a1194816a7f6c36bc518de45aa06c8');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__e9a1194816a7f6c36bc518de45aa06c8

meta::function('create', <<'__3635039812e83a384cadd7e81bf4805b');
my ($name, $value) = @_;

messages::error("Attribute $name already exists.") if grep $_ eq $name, keys %data;
if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__3635039812e83a384cadd7e81bf4805b

meta::function('edit', <<'__e148f15260a169549bb9faf888b89e2e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__e148f15260a169549bb9faf888b89e2e

meta::function('export', <<'__c750d5e8911eea5289c09687f0987f68');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  messages::error("Not enough arguments");
}
__c750d5e8911eea5289c09687f0987f68

meta::function('hash', <<'__9a26de7e7cbb9218461779d8daf79002');
my ($data) = @_;
fast_hash($data);
__9a26de7e7cbb9218461779d8daf79002

meta::function('import', <<'__6b465b501ed2e590742c9538a51add80');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__6b465b501ed2e590742c9538a51add80

meta::function('import-bundle', <<'__87c31c42c0ebfe3471bac28857efc764');
eval join '', <STDIN>;
messages::error($@) if $@;
__87c31c42c0ebfe3471bac28857efc764

meta::function('lock', <<'__224b5b38a80ec0bef8afba786b1b876e');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__224b5b38a80ec0bef8afba786b1b876e

meta::function('ls', <<'__c4d729886d9e4df48f068bfc34c57634');
my $criteria = join '|', @_;
my @lines = grep /$criteria/, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__c4d729886d9e4df48f068bfc34c57634

meta::function('ls-a', <<'__9b51b6802023c3f85e083b18ee0e66e8');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . sprintf('%6d  ', length(serialize_single($_))) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__9b51b6802023c3f85e083b18ee0e66e8

meta::function('mv', <<'__831188a8239540b0722a2648073d6a88');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

return messages::error("'$from' does not exist.") unless grep $from, keys %data;
return messages::error("The namepsace '$destination_namespace' does not exist") unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__831188a8239540b0722a2648073d6a88

meta::function('perl', <<'__e3ecc4a2e342a050208374f08e9cf9e8');
my $result = eval($_[0]);
$@ ? $@ : $result;
__e3ecc4a2e342a050208374f08e9cf9e8

meta::function('pop-state', <<'__e3eae3b3420ae5686c99ba78c85b6688');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__e3eae3b3420ae5686c99ba78c85b6688

meta::function('preprocess', <<'__1f2fe68a8b74b100e352b88b0f80a260');
# Implements a simple preprocessing language. Directives are functions:

# = function [arguments...]
# Each function can be supplied with one or more arguments. These are mapped straight
# into the function's argument list.

# This syntax is deliberately not very flexible. You shouldn't be using complex
# expressions for these things. The beginning delimiter must be preceded by either
# nothing or only whitespace. By default it is =, but that can be changed.

# Template functions are defined by creating template:: attributes.

my ($string, %options) = @_;
my $delimiter          = $options{delimiter} || '=';

1 while $string =~ s/^\s*$delimiter\s+([^\s]+)\s*(.*)$/${\(&{"template::$1"}($2))}/omg;

$string;
__1f2fe68a8b74b100e352b88b0f80a260

meta::function('pull', <<'__20174170a253f060e408d8d38242aa0a');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__20174170a253f060e408d8d38242aa0a

meta::function('push-state', <<'__8f5cf6d01bef7e78452bf9a0e11554b0');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__8f5cf6d01bef7e78452bf9a0e11554b0

meta::function('reload', 'execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;');
meta::function('rm', <<'__e9ba58a4f738c1082e8434c865fe405c');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__e9ba58a4f738c1082e8434c865fe405c

meta::function('save', <<'__39acaec4fa4523807c5d13813f948e60');
my $serialized_data = serialize();
my $final_state     = state();

my $temporary_filename = temporary_name();
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if (! verify()) {
  terminal::message('error', "The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).");
  messages::error("$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  messages::warning($@) if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
  terminal::message('info', "$0 saved successfully.");
}
__39acaec4fa4523807c5d13813f948e60

meta::function('serialize', <<'__c0d0324cdb78b5a04a7c4c40e68356b8');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && (! $criteria || m/$criteria/), sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;
__c0d0324cdb78b5a04a7c4c40e68356b8

meta::function('serialize_single', <<'__508b57e07401be981bd0b62578eb97ea');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $delimiter          = '__' . fast_hash($contents);
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename($name);

return "$meta_function_name('$invocation_name', '$contents');"   if $contents =~ /^[^\n']*$/;
return "$meta_function_name('$invocation_name', \"$contents\");" if $contents =~ /^[^\n"\\\$@%&]*$/;
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__508b57e07401be981bd0b62578eb97ea

meta::function('shell', <<'__a26ebb40ab143b30095bb08c79129354');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = name() . '$ ';
}
__a26ebb40ab143b30095bb08c79129354

meta::function('size', 'length(serialize());');
meta::function('snapshot', <<'__ca1cda4868e39e9c41656c684c693a38');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('info', "Created snapshot at $finalname.");
__ca1cda4868e39e9c41656c684c693a38

meta::function('state', 'fast_hash(serialize());');
meta::function('unlock', <<'__224b5b38a80ec0bef8afba786b1b876e');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__224b5b38a80ec0bef8afba786b1b876e

meta::function('update-from', <<'__29ab6b0808ff810469ee09e8250b5390');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.

my $target  = $_[0] or die 'Must specify another script to pull data from.';
my @options = grep /^-/, @_;

terminal::message('info', 'Replicating state...');
&{'push-state'}();

terminal::message('info', 'Updating meta attributes...');
eval join('', qx|$target serialize '^meta::'|);
reload();

unless (verify()) {
  terminal::message('warning', 'One of the meta-attributes triggered a verification failure.');
  terminal::message('warning', 'It is possible, though indicative of bad design if true, that one of the non-meta attributes');
  terminal::message('warning', 'will solve this problem.');
}

terminal::message('info', 'Updating non-meta attributes...');
my $combined_pattern = join '|', grep(! /^meta::/ && $transient{inherit}{$_}, sort keys %{$transient{inherit}});
eval join('', qx|$target serialize '$combined_pattern'|);
reload();

if (verify()) {
  terminal::message('info', "Successfully updated from $_[0]. Run pop-state to undo this change.");
} elsif (grep /^--force$/o || /^-f$/o, @options) {
  terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
  terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
  terminal::message('info',    'Run pop-state to undo the update and return to a working state.');
} else {
  terminal::message('error', 'Verification failed after the upgrade was complete.');
  terminal::message('info',  "$0 has been reverted to its pre-upgrade state.");
  terminal::message('info',  "If you want to upgrade and keep the failure state, then run update-from $target --force.");
  &{'pop-state'}();
}
__29ab6b0808ff810469ee09e8250b5390

meta::function('usage', <<'__5864e808372870b83f073f949bc002b8');
<<"EOD" . ls ();
Usage: $0 [options] action [arguments]
Defined actions (and the attribute that defines them):
EOD
__5864e808372870b83f073f949bc002b8

meta::function('verify', <<'__a9f34f105cf9d1904869e5f0ca8fdfd8');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;
unlink $temporary_filename if $result;
$transient{temporary_filename} = $temporary_filename;

$result;
__a9f34f105cf9d1904869e5f0ca8fdfd8

meta::function('vim', <<'__4bb5b5b84f0fe1f43c95b11c528adcc3');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__4bb5b5b84f0fe1f43c95b11c528adcc3

meta::internal_function('associate', <<'__8d6854866c9e4b2e790f9d8cb0faefd8');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__8d6854866c9e4b2e790f9d8cb0faefd8

meta::internal_function('basename', <<'__90dcfe980f60186ca73eb5804e33e940');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__90dcfe980f60186ca73eb5804e33e940

meta::internal_function('complete', <<'__17b92f0ce1c662fc29fac1081005d3d0');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__17b92f0ce1c662fc29fac1081005d3d0

meta::internal_function('execute', <<'__e7f72ae8f9f8be3587da26d042445a60');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__e7f72ae8f9f8be3587da26d042445a60

meta::internal_function('fast_hash', <<'__1402f938bb3f9c8c55813f66a01f7640');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = substr($data, $piece_size * 8) . length($data), map substr($data, $piece_size * $_, $piece_size), 0 .. 7;
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__1402f938bb3f9c8c55813f66a01f7640

meta::internal_function('file::read', <<'__0be43bc0509e2668c1917dd8878f505e');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__0be43bc0509e2668c1917dd8878f505e

meta::internal_function('file::write', <<'__026bac5614aee674d5ad9a341d2c4be8');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__026bac5614aee674d5ad9a341d2c4be8

meta::internal_function('fnv_hash', <<'__94ebec78c1fe9bc80e4f6e2c70c4c488');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

(($hash ^= $_) *= $fnv_prime) %= $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__94ebec78c1fe9bc80e4f6e2c70c4c488

meta::internal_function('invoke_editor_on', <<'__c810c120392b0de0a77ab8c81a8c67b8');
my ($data, %options) = @_;
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my $filename         = temporary_name() . $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__c810c120392b0de0a77ab8c81a8c67b8

meta::internal_function('messages::error', <<'__27e50d66ebfd1be4f31f3b489824ceb0');
my ($message) = @_;
terminal::message('error', $message);
die;
__27e50d66ebfd1be4f31f3b489824ceb0

meta::internal_function('messages::warning', <<'__70c4dfe31e4a0a80679722e0424397f4');
my ($message) = @_;
terminal::message('warning', $message);
__70c4dfe31e4a0a80679722e0424397f4

meta::internal_function('namespace', <<'__e2799868bca51600b966845038cc7eb8');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__e2799868bca51600b966845038cc7eb8

meta::internal_function('retrieve', '@data{@_};');
meta::internal_function('state_based_filename', <<'__29845b326633c6f0bc9b197c84802724');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__29845b326633c6f0bc9b197c84802724

meta::internal_function('temporary_name', <<'__fe8eb68ec4d017b42020e454b0dc0140');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
$temporary_filename;
__fe8eb68ec4d017b42020e454b0dc0140

meta::library('terminal', <<'__e9356da06debb0949f6b74604d4561b0');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__e9356da06debb0949f6b74604d4561b0

meta::internal('runtime', <<'__d16c81a08c6fa3aed5ba3c402cc2fa6c');
my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));
reload();

my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' and messages::warning("Unknown action: $function_name") unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

END {
  save() unless $initial_state eq state();
}

__d16c81a08c6fa3aed5ba3c402cc2fa6c

__END__